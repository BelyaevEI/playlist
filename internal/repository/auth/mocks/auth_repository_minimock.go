// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/BelyaevEI/playlist/internal/repository/auth.AuthRepository -o auth_repository_minimock.go -n AuthRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/BelyaevEI/playlist/internal/model"
	"github.com/gojuno/minimock/v3"
)

// AuthRepositoryMock implements mm_auth.AuthRepository
type AuthRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCheckLoginUnique          func(ctx context.Context, s1 string) (err error)
	funcCheckLoginUniqueOrigin    string
	inspectFuncCheckLoginUnique   func(ctx context.Context, s1 string)
	afterCheckLoginUniqueCounter  uint64
	beforeCheckLoginUniqueCounter uint64
	CheckLoginUniqueMock          mAuthRepositoryMockCheckLoginUnique

	funcCreateUser          func(ctx context.Context, login string, hashPassword string, secretKey string) (err error)
	funcCreateUserOrigin    string
	inspectFuncCreateUser   func(ctx context.Context, login string, hashPassword string, secretKey string)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mAuthRepositoryMockCreateUser

	funcSelectUser          func(ctx context.Context, userLogin *model.UserLogin) (u1 model.UserLogin, err error)
	funcSelectUserOrigin    string
	inspectFuncSelectUser   func(ctx context.Context, userLogin *model.UserLogin)
	afterSelectUserCounter  uint64
	beforeSelectUserCounter uint64
	SelectUserMock          mAuthRepositoryMockSelectUser
}

// NewAuthRepositoryMock returns a mock for mm_auth.AuthRepository
func NewAuthRepositoryMock(t minimock.Tester) *AuthRepositoryMock {
	m := &AuthRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CheckLoginUniqueMock = mAuthRepositoryMockCheckLoginUnique{mock: m}
	m.CheckLoginUniqueMock.callArgs = []*AuthRepositoryMockCheckLoginUniqueParams{}

	m.CreateUserMock = mAuthRepositoryMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*AuthRepositoryMockCreateUserParams{}

	m.SelectUserMock = mAuthRepositoryMockSelectUser{mock: m}
	m.SelectUserMock.callArgs = []*AuthRepositoryMockSelectUserParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mAuthRepositoryMockCheckLoginUnique struct {
	optional           bool
	mock               *AuthRepositoryMock
	defaultExpectation *AuthRepositoryMockCheckLoginUniqueExpectation
	expectations       []*AuthRepositoryMockCheckLoginUniqueExpectation

	callArgs []*AuthRepositoryMockCheckLoginUniqueParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthRepositoryMockCheckLoginUniqueExpectation specifies expectation struct of the AuthRepository.CheckLoginUnique
type AuthRepositoryMockCheckLoginUniqueExpectation struct {
	mock               *AuthRepositoryMock
	params             *AuthRepositoryMockCheckLoginUniqueParams
	paramPtrs          *AuthRepositoryMockCheckLoginUniqueParamPtrs
	expectationOrigins AuthRepositoryMockCheckLoginUniqueExpectationOrigins
	results            *AuthRepositoryMockCheckLoginUniqueResults
	returnOrigin       string
	Counter            uint64
}

// AuthRepositoryMockCheckLoginUniqueParams contains parameters of the AuthRepository.CheckLoginUnique
type AuthRepositoryMockCheckLoginUniqueParams struct {
	ctx context.Context
	s1  string
}

// AuthRepositoryMockCheckLoginUniqueParamPtrs contains pointers to parameters of the AuthRepository.CheckLoginUnique
type AuthRepositoryMockCheckLoginUniqueParamPtrs struct {
	ctx *context.Context
	s1  *string
}

// AuthRepositoryMockCheckLoginUniqueResults contains results of the AuthRepository.CheckLoginUnique
type AuthRepositoryMockCheckLoginUniqueResults struct {
	err error
}

// AuthRepositoryMockCheckLoginUniqueOrigins contains origins of expectations of the AuthRepository.CheckLoginUnique
type AuthRepositoryMockCheckLoginUniqueExpectationOrigins struct {
	origin    string
	originCtx string
	originS1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckLoginUnique *mAuthRepositoryMockCheckLoginUnique) Optional() *mAuthRepositoryMockCheckLoginUnique {
	mmCheckLoginUnique.optional = true
	return mmCheckLoginUnique
}

// Expect sets up expected params for AuthRepository.CheckLoginUnique
func (mmCheckLoginUnique *mAuthRepositoryMockCheckLoginUnique) Expect(ctx context.Context, s1 string) *mAuthRepositoryMockCheckLoginUnique {
	if mmCheckLoginUnique.mock.funcCheckLoginUnique != nil {
		mmCheckLoginUnique.mock.t.Fatalf("AuthRepositoryMock.CheckLoginUnique mock is already set by Set")
	}

	if mmCheckLoginUnique.defaultExpectation == nil {
		mmCheckLoginUnique.defaultExpectation = &AuthRepositoryMockCheckLoginUniqueExpectation{}
	}

	if mmCheckLoginUnique.defaultExpectation.paramPtrs != nil {
		mmCheckLoginUnique.mock.t.Fatalf("AuthRepositoryMock.CheckLoginUnique mock is already set by ExpectParams functions")
	}

	mmCheckLoginUnique.defaultExpectation.params = &AuthRepositoryMockCheckLoginUniqueParams{ctx, s1}
	mmCheckLoginUnique.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckLoginUnique.expectations {
		if minimock.Equal(e.params, mmCheckLoginUnique.defaultExpectation.params) {
			mmCheckLoginUnique.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckLoginUnique.defaultExpectation.params)
		}
	}

	return mmCheckLoginUnique
}

// ExpectCtxParam1 sets up expected param ctx for AuthRepository.CheckLoginUnique
func (mmCheckLoginUnique *mAuthRepositoryMockCheckLoginUnique) ExpectCtxParam1(ctx context.Context) *mAuthRepositoryMockCheckLoginUnique {
	if mmCheckLoginUnique.mock.funcCheckLoginUnique != nil {
		mmCheckLoginUnique.mock.t.Fatalf("AuthRepositoryMock.CheckLoginUnique mock is already set by Set")
	}

	if mmCheckLoginUnique.defaultExpectation == nil {
		mmCheckLoginUnique.defaultExpectation = &AuthRepositoryMockCheckLoginUniqueExpectation{}
	}

	if mmCheckLoginUnique.defaultExpectation.params != nil {
		mmCheckLoginUnique.mock.t.Fatalf("AuthRepositoryMock.CheckLoginUnique mock is already set by Expect")
	}

	if mmCheckLoginUnique.defaultExpectation.paramPtrs == nil {
		mmCheckLoginUnique.defaultExpectation.paramPtrs = &AuthRepositoryMockCheckLoginUniqueParamPtrs{}
	}
	mmCheckLoginUnique.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckLoginUnique.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckLoginUnique
}

// ExpectS1Param2 sets up expected param s1 for AuthRepository.CheckLoginUnique
func (mmCheckLoginUnique *mAuthRepositoryMockCheckLoginUnique) ExpectS1Param2(s1 string) *mAuthRepositoryMockCheckLoginUnique {
	if mmCheckLoginUnique.mock.funcCheckLoginUnique != nil {
		mmCheckLoginUnique.mock.t.Fatalf("AuthRepositoryMock.CheckLoginUnique mock is already set by Set")
	}

	if mmCheckLoginUnique.defaultExpectation == nil {
		mmCheckLoginUnique.defaultExpectation = &AuthRepositoryMockCheckLoginUniqueExpectation{}
	}

	if mmCheckLoginUnique.defaultExpectation.params != nil {
		mmCheckLoginUnique.mock.t.Fatalf("AuthRepositoryMock.CheckLoginUnique mock is already set by Expect")
	}

	if mmCheckLoginUnique.defaultExpectation.paramPtrs == nil {
		mmCheckLoginUnique.defaultExpectation.paramPtrs = &AuthRepositoryMockCheckLoginUniqueParamPtrs{}
	}
	mmCheckLoginUnique.defaultExpectation.paramPtrs.s1 = &s1
	mmCheckLoginUnique.defaultExpectation.expectationOrigins.originS1 = minimock.CallerInfo(1)

	return mmCheckLoginUnique
}

// Inspect accepts an inspector function that has same arguments as the AuthRepository.CheckLoginUnique
func (mmCheckLoginUnique *mAuthRepositoryMockCheckLoginUnique) Inspect(f func(ctx context.Context, s1 string)) *mAuthRepositoryMockCheckLoginUnique {
	if mmCheckLoginUnique.mock.inspectFuncCheckLoginUnique != nil {
		mmCheckLoginUnique.mock.t.Fatalf("Inspect function is already set for AuthRepositoryMock.CheckLoginUnique")
	}

	mmCheckLoginUnique.mock.inspectFuncCheckLoginUnique = f

	return mmCheckLoginUnique
}

// Return sets up results that will be returned by AuthRepository.CheckLoginUnique
func (mmCheckLoginUnique *mAuthRepositoryMockCheckLoginUnique) Return(err error) *AuthRepositoryMock {
	if mmCheckLoginUnique.mock.funcCheckLoginUnique != nil {
		mmCheckLoginUnique.mock.t.Fatalf("AuthRepositoryMock.CheckLoginUnique mock is already set by Set")
	}

	if mmCheckLoginUnique.defaultExpectation == nil {
		mmCheckLoginUnique.defaultExpectation = &AuthRepositoryMockCheckLoginUniqueExpectation{mock: mmCheckLoginUnique.mock}
	}
	mmCheckLoginUnique.defaultExpectation.results = &AuthRepositoryMockCheckLoginUniqueResults{err}
	mmCheckLoginUnique.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckLoginUnique.mock
}

// Set uses given function f to mock the AuthRepository.CheckLoginUnique method
func (mmCheckLoginUnique *mAuthRepositoryMockCheckLoginUnique) Set(f func(ctx context.Context, s1 string) (err error)) *AuthRepositoryMock {
	if mmCheckLoginUnique.defaultExpectation != nil {
		mmCheckLoginUnique.mock.t.Fatalf("Default expectation is already set for the AuthRepository.CheckLoginUnique method")
	}

	if len(mmCheckLoginUnique.expectations) > 0 {
		mmCheckLoginUnique.mock.t.Fatalf("Some expectations are already set for the AuthRepository.CheckLoginUnique method")
	}

	mmCheckLoginUnique.mock.funcCheckLoginUnique = f
	mmCheckLoginUnique.mock.funcCheckLoginUniqueOrigin = minimock.CallerInfo(1)
	return mmCheckLoginUnique.mock
}

// When sets expectation for the AuthRepository.CheckLoginUnique which will trigger the result defined by the following
// Then helper
func (mmCheckLoginUnique *mAuthRepositoryMockCheckLoginUnique) When(ctx context.Context, s1 string) *AuthRepositoryMockCheckLoginUniqueExpectation {
	if mmCheckLoginUnique.mock.funcCheckLoginUnique != nil {
		mmCheckLoginUnique.mock.t.Fatalf("AuthRepositoryMock.CheckLoginUnique mock is already set by Set")
	}

	expectation := &AuthRepositoryMockCheckLoginUniqueExpectation{
		mock:               mmCheckLoginUnique.mock,
		params:             &AuthRepositoryMockCheckLoginUniqueParams{ctx, s1},
		expectationOrigins: AuthRepositoryMockCheckLoginUniqueExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckLoginUnique.expectations = append(mmCheckLoginUnique.expectations, expectation)
	return expectation
}

// Then sets up AuthRepository.CheckLoginUnique return parameters for the expectation previously defined by the When method
func (e *AuthRepositoryMockCheckLoginUniqueExpectation) Then(err error) *AuthRepositoryMock {
	e.results = &AuthRepositoryMockCheckLoginUniqueResults{err}
	return e.mock
}

// Times sets number of times AuthRepository.CheckLoginUnique should be invoked
func (mmCheckLoginUnique *mAuthRepositoryMockCheckLoginUnique) Times(n uint64) *mAuthRepositoryMockCheckLoginUnique {
	if n == 0 {
		mmCheckLoginUnique.mock.t.Fatalf("Times of AuthRepositoryMock.CheckLoginUnique mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckLoginUnique.expectedInvocations, n)
	mmCheckLoginUnique.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckLoginUnique
}

func (mmCheckLoginUnique *mAuthRepositoryMockCheckLoginUnique) invocationsDone() bool {
	if len(mmCheckLoginUnique.expectations) == 0 && mmCheckLoginUnique.defaultExpectation == nil && mmCheckLoginUnique.mock.funcCheckLoginUnique == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckLoginUnique.mock.afterCheckLoginUniqueCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckLoginUnique.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckLoginUnique implements mm_auth.AuthRepository
func (mmCheckLoginUnique *AuthRepositoryMock) CheckLoginUnique(ctx context.Context, s1 string) (err error) {
	mm_atomic.AddUint64(&mmCheckLoginUnique.beforeCheckLoginUniqueCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckLoginUnique.afterCheckLoginUniqueCounter, 1)

	mmCheckLoginUnique.t.Helper()

	if mmCheckLoginUnique.inspectFuncCheckLoginUnique != nil {
		mmCheckLoginUnique.inspectFuncCheckLoginUnique(ctx, s1)
	}

	mm_params := AuthRepositoryMockCheckLoginUniqueParams{ctx, s1}

	// Record call args
	mmCheckLoginUnique.CheckLoginUniqueMock.mutex.Lock()
	mmCheckLoginUnique.CheckLoginUniqueMock.callArgs = append(mmCheckLoginUnique.CheckLoginUniqueMock.callArgs, &mm_params)
	mmCheckLoginUnique.CheckLoginUniqueMock.mutex.Unlock()

	for _, e := range mmCheckLoginUnique.CheckLoginUniqueMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCheckLoginUnique.CheckLoginUniqueMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckLoginUnique.CheckLoginUniqueMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckLoginUnique.CheckLoginUniqueMock.defaultExpectation.params
		mm_want_ptrs := mmCheckLoginUnique.CheckLoginUniqueMock.defaultExpectation.paramPtrs

		mm_got := AuthRepositoryMockCheckLoginUniqueParams{ctx, s1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckLoginUnique.t.Errorf("AuthRepositoryMock.CheckLoginUnique got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckLoginUnique.CheckLoginUniqueMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.s1 != nil && !minimock.Equal(*mm_want_ptrs.s1, mm_got.s1) {
				mmCheckLoginUnique.t.Errorf("AuthRepositoryMock.CheckLoginUnique got unexpected parameter s1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckLoginUnique.CheckLoginUniqueMock.defaultExpectation.expectationOrigins.originS1, *mm_want_ptrs.s1, mm_got.s1, minimock.Diff(*mm_want_ptrs.s1, mm_got.s1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckLoginUnique.t.Errorf("AuthRepositoryMock.CheckLoginUnique got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckLoginUnique.CheckLoginUniqueMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckLoginUnique.CheckLoginUniqueMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckLoginUnique.t.Fatal("No results are set for the AuthRepositoryMock.CheckLoginUnique")
		}
		return (*mm_results).err
	}
	if mmCheckLoginUnique.funcCheckLoginUnique != nil {
		return mmCheckLoginUnique.funcCheckLoginUnique(ctx, s1)
	}
	mmCheckLoginUnique.t.Fatalf("Unexpected call to AuthRepositoryMock.CheckLoginUnique. %v %v", ctx, s1)
	return
}

// CheckLoginUniqueAfterCounter returns a count of finished AuthRepositoryMock.CheckLoginUnique invocations
func (mmCheckLoginUnique *AuthRepositoryMock) CheckLoginUniqueAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckLoginUnique.afterCheckLoginUniqueCounter)
}

// CheckLoginUniqueBeforeCounter returns a count of AuthRepositoryMock.CheckLoginUnique invocations
func (mmCheckLoginUnique *AuthRepositoryMock) CheckLoginUniqueBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckLoginUnique.beforeCheckLoginUniqueCounter)
}

// Calls returns a list of arguments used in each call to AuthRepositoryMock.CheckLoginUnique.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckLoginUnique *mAuthRepositoryMockCheckLoginUnique) Calls() []*AuthRepositoryMockCheckLoginUniqueParams {
	mmCheckLoginUnique.mutex.RLock()

	argCopy := make([]*AuthRepositoryMockCheckLoginUniqueParams, len(mmCheckLoginUnique.callArgs))
	copy(argCopy, mmCheckLoginUnique.callArgs)

	mmCheckLoginUnique.mutex.RUnlock()

	return argCopy
}

// MinimockCheckLoginUniqueDone returns true if the count of the CheckLoginUnique invocations corresponds
// the number of defined expectations
func (m *AuthRepositoryMock) MinimockCheckLoginUniqueDone() bool {
	if m.CheckLoginUniqueMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckLoginUniqueMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckLoginUniqueMock.invocationsDone()
}

// MinimockCheckLoginUniqueInspect logs each unmet expectation
func (m *AuthRepositoryMock) MinimockCheckLoginUniqueInspect() {
	for _, e := range m.CheckLoginUniqueMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthRepositoryMock.CheckLoginUnique at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckLoginUniqueCounter := mm_atomic.LoadUint64(&m.afterCheckLoginUniqueCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckLoginUniqueMock.defaultExpectation != nil && afterCheckLoginUniqueCounter < 1 {
		if m.CheckLoginUniqueMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthRepositoryMock.CheckLoginUnique at\n%s", m.CheckLoginUniqueMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthRepositoryMock.CheckLoginUnique at\n%s with params: %#v", m.CheckLoginUniqueMock.defaultExpectation.expectationOrigins.origin, *m.CheckLoginUniqueMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckLoginUnique != nil && afterCheckLoginUniqueCounter < 1 {
		m.t.Errorf("Expected call to AuthRepositoryMock.CheckLoginUnique at\n%s", m.funcCheckLoginUniqueOrigin)
	}

	if !m.CheckLoginUniqueMock.invocationsDone() && afterCheckLoginUniqueCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthRepositoryMock.CheckLoginUnique at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckLoginUniqueMock.expectedInvocations), m.CheckLoginUniqueMock.expectedInvocationsOrigin, afterCheckLoginUniqueCounter)
	}
}

type mAuthRepositoryMockCreateUser struct {
	optional           bool
	mock               *AuthRepositoryMock
	defaultExpectation *AuthRepositoryMockCreateUserExpectation
	expectations       []*AuthRepositoryMockCreateUserExpectation

	callArgs []*AuthRepositoryMockCreateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthRepositoryMockCreateUserExpectation specifies expectation struct of the AuthRepository.CreateUser
type AuthRepositoryMockCreateUserExpectation struct {
	mock               *AuthRepositoryMock
	params             *AuthRepositoryMockCreateUserParams
	paramPtrs          *AuthRepositoryMockCreateUserParamPtrs
	expectationOrigins AuthRepositoryMockCreateUserExpectationOrigins
	results            *AuthRepositoryMockCreateUserResults
	returnOrigin       string
	Counter            uint64
}

// AuthRepositoryMockCreateUserParams contains parameters of the AuthRepository.CreateUser
type AuthRepositoryMockCreateUserParams struct {
	ctx          context.Context
	login        string
	hashPassword string
	secretKey    string
}

// AuthRepositoryMockCreateUserParamPtrs contains pointers to parameters of the AuthRepository.CreateUser
type AuthRepositoryMockCreateUserParamPtrs struct {
	ctx          *context.Context
	login        *string
	hashPassword *string
	secretKey    *string
}

// AuthRepositoryMockCreateUserResults contains results of the AuthRepository.CreateUser
type AuthRepositoryMockCreateUserResults struct {
	err error
}

// AuthRepositoryMockCreateUserOrigins contains origins of expectations of the AuthRepository.CreateUser
type AuthRepositoryMockCreateUserExpectationOrigins struct {
	origin             string
	originCtx          string
	originLogin        string
	originHashPassword string
	originSecretKey    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateUser *mAuthRepositoryMockCreateUser) Optional() *mAuthRepositoryMockCreateUser {
	mmCreateUser.optional = true
	return mmCreateUser
}

// Expect sets up expected params for AuthRepository.CreateUser
func (mmCreateUser *mAuthRepositoryMockCreateUser) Expect(ctx context.Context, login string, hashPassword string, secretKey string) *mAuthRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("AuthRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &AuthRepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.paramPtrs != nil {
		mmCreateUser.mock.t.Fatalf("AuthRepositoryMock.CreateUser mock is already set by ExpectParams functions")
	}

	mmCreateUser.defaultExpectation.params = &AuthRepositoryMockCreateUserParams{ctx, login, hashPassword, secretKey}
	mmCreateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// ExpectCtxParam1 sets up expected param ctx for AuthRepository.CreateUser
func (mmCreateUser *mAuthRepositoryMockCreateUser) ExpectCtxParam1(ctx context.Context) *mAuthRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("AuthRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &AuthRepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("AuthRepositoryMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &AuthRepositoryMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateUser
}

// ExpectLoginParam2 sets up expected param login for AuthRepository.CreateUser
func (mmCreateUser *mAuthRepositoryMockCreateUser) ExpectLoginParam2(login string) *mAuthRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("AuthRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &AuthRepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("AuthRepositoryMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &AuthRepositoryMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.login = &login
	mmCreateUser.defaultExpectation.expectationOrigins.originLogin = minimock.CallerInfo(1)

	return mmCreateUser
}

// ExpectHashPasswordParam3 sets up expected param hashPassword for AuthRepository.CreateUser
func (mmCreateUser *mAuthRepositoryMockCreateUser) ExpectHashPasswordParam3(hashPassword string) *mAuthRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("AuthRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &AuthRepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("AuthRepositoryMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &AuthRepositoryMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.hashPassword = &hashPassword
	mmCreateUser.defaultExpectation.expectationOrigins.originHashPassword = minimock.CallerInfo(1)

	return mmCreateUser
}

// ExpectSecretKeyParam4 sets up expected param secretKey for AuthRepository.CreateUser
func (mmCreateUser *mAuthRepositoryMockCreateUser) ExpectSecretKeyParam4(secretKey string) *mAuthRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("AuthRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &AuthRepositoryMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("AuthRepositoryMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &AuthRepositoryMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.secretKey = &secretKey
	mmCreateUser.defaultExpectation.expectationOrigins.originSecretKey = minimock.CallerInfo(1)

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the AuthRepository.CreateUser
func (mmCreateUser *mAuthRepositoryMockCreateUser) Inspect(f func(ctx context.Context, login string, hashPassword string, secretKey string)) *mAuthRepositoryMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for AuthRepositoryMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by AuthRepository.CreateUser
func (mmCreateUser *mAuthRepositoryMockCreateUser) Return(err error) *AuthRepositoryMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("AuthRepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &AuthRepositoryMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &AuthRepositoryMockCreateUserResults{err}
	mmCreateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// Set uses given function f to mock the AuthRepository.CreateUser method
func (mmCreateUser *mAuthRepositoryMockCreateUser) Set(f func(ctx context.Context, login string, hashPassword string, secretKey string) (err error)) *AuthRepositoryMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the AuthRepository.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the AuthRepository.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	mmCreateUser.mock.funcCreateUserOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// When sets expectation for the AuthRepository.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mAuthRepositoryMockCreateUser) When(ctx context.Context, login string, hashPassword string, secretKey string) *AuthRepositoryMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("AuthRepositoryMock.CreateUser mock is already set by Set")
	}

	expectation := &AuthRepositoryMockCreateUserExpectation{
		mock:               mmCreateUser.mock,
		params:             &AuthRepositoryMockCreateUserParams{ctx, login, hashPassword, secretKey},
		expectationOrigins: AuthRepositoryMockCreateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up AuthRepository.CreateUser return parameters for the expectation previously defined by the When method
func (e *AuthRepositoryMockCreateUserExpectation) Then(err error) *AuthRepositoryMock {
	e.results = &AuthRepositoryMockCreateUserResults{err}
	return e.mock
}

// Times sets number of times AuthRepository.CreateUser should be invoked
func (mmCreateUser *mAuthRepositoryMockCreateUser) Times(n uint64) *mAuthRepositoryMockCreateUser {
	if n == 0 {
		mmCreateUser.mock.t.Fatalf("Times of AuthRepositoryMock.CreateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateUser.expectedInvocations, n)
	mmCreateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateUser
}

func (mmCreateUser *mAuthRepositoryMockCreateUser) invocationsDone() bool {
	if len(mmCreateUser.expectations) == 0 && mmCreateUser.defaultExpectation == nil && mmCreateUser.mock.funcCreateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateUser.mock.afterCreateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateUser implements mm_auth.AuthRepository
func (mmCreateUser *AuthRepositoryMock) CreateUser(ctx context.Context, login string, hashPassword string, secretKey string) (err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	mmCreateUser.t.Helper()

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx, login, hashPassword, secretKey)
	}

	mm_params := AuthRepositoryMockCreateUserParams{ctx, login, hashPassword, secretKey}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, &mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_want_ptrs := mmCreateUser.CreateUserMock.defaultExpectation.paramPtrs

		mm_got := AuthRepositoryMockCreateUserParams{ctx, login, hashPassword, secretKey}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateUser.t.Errorf("AuthRepositoryMock.CreateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.login != nil && !minimock.Equal(*mm_want_ptrs.login, mm_got.login) {
				mmCreateUser.t.Errorf("AuthRepositoryMock.CreateUser got unexpected parameter login, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originLogin, *mm_want_ptrs.login, mm_got.login, minimock.Diff(*mm_want_ptrs.login, mm_got.login))
			}

			if mm_want_ptrs.hashPassword != nil && !minimock.Equal(*mm_want_ptrs.hashPassword, mm_got.hashPassword) {
				mmCreateUser.t.Errorf("AuthRepositoryMock.CreateUser got unexpected parameter hashPassword, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originHashPassword, *mm_want_ptrs.hashPassword, mm_got.hashPassword, minimock.Diff(*mm_want_ptrs.hashPassword, mm_got.hashPassword))
			}

			if mm_want_ptrs.secretKey != nil && !minimock.Equal(*mm_want_ptrs.secretKey, mm_got.secretKey) {
				mmCreateUser.t.Errorf("AuthRepositoryMock.CreateUser got unexpected parameter secretKey, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originSecretKey, *mm_want_ptrs.secretKey, mm_got.secretKey, minimock.Diff(*mm_want_ptrs.secretKey, mm_got.secretKey))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("AuthRepositoryMock.CreateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the AuthRepositoryMock.CreateUser")
		}
		return (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx, login, hashPassword, secretKey)
	}
	mmCreateUser.t.Fatalf("Unexpected call to AuthRepositoryMock.CreateUser. %v %v %v %v", ctx, login, hashPassword, secretKey)
	return
}

// CreateUserAfterCounter returns a count of finished AuthRepositoryMock.CreateUser invocations
func (mmCreateUser *AuthRepositoryMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of AuthRepositoryMock.CreateUser invocations
func (mmCreateUser *AuthRepositoryMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to AuthRepositoryMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mAuthRepositoryMockCreateUser) Calls() []*AuthRepositoryMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*AuthRepositoryMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *AuthRepositoryMock) MinimockCreateUserDone() bool {
	if m.CreateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateUserMock.invocationsDone()
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *AuthRepositoryMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthRepositoryMock.CreateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateUserCounter := mm_atomic.LoadUint64(&m.afterCreateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && afterCreateUserCounter < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthRepositoryMock.CreateUser at\n%s", m.CreateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthRepositoryMock.CreateUser at\n%s with params: %#v", m.CreateUserMock.defaultExpectation.expectationOrigins.origin, *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && afterCreateUserCounter < 1 {
		m.t.Errorf("Expected call to AuthRepositoryMock.CreateUser at\n%s", m.funcCreateUserOrigin)
	}

	if !m.CreateUserMock.invocationsDone() && afterCreateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthRepositoryMock.CreateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateUserMock.expectedInvocations), m.CreateUserMock.expectedInvocationsOrigin, afterCreateUserCounter)
	}
}

type mAuthRepositoryMockSelectUser struct {
	optional           bool
	mock               *AuthRepositoryMock
	defaultExpectation *AuthRepositoryMockSelectUserExpectation
	expectations       []*AuthRepositoryMockSelectUserExpectation

	callArgs []*AuthRepositoryMockSelectUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthRepositoryMockSelectUserExpectation specifies expectation struct of the AuthRepository.SelectUser
type AuthRepositoryMockSelectUserExpectation struct {
	mock               *AuthRepositoryMock
	params             *AuthRepositoryMockSelectUserParams
	paramPtrs          *AuthRepositoryMockSelectUserParamPtrs
	expectationOrigins AuthRepositoryMockSelectUserExpectationOrigins
	results            *AuthRepositoryMockSelectUserResults
	returnOrigin       string
	Counter            uint64
}

// AuthRepositoryMockSelectUserParams contains parameters of the AuthRepository.SelectUser
type AuthRepositoryMockSelectUserParams struct {
	ctx       context.Context
	userLogin *model.UserLogin
}

// AuthRepositoryMockSelectUserParamPtrs contains pointers to parameters of the AuthRepository.SelectUser
type AuthRepositoryMockSelectUserParamPtrs struct {
	ctx       *context.Context
	userLogin **model.UserLogin
}

// AuthRepositoryMockSelectUserResults contains results of the AuthRepository.SelectUser
type AuthRepositoryMockSelectUserResults struct {
	u1  model.UserLogin
	err error
}

// AuthRepositoryMockSelectUserOrigins contains origins of expectations of the AuthRepository.SelectUser
type AuthRepositoryMockSelectUserExpectationOrigins struct {
	origin          string
	originCtx       string
	originUserLogin string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSelectUser *mAuthRepositoryMockSelectUser) Optional() *mAuthRepositoryMockSelectUser {
	mmSelectUser.optional = true
	return mmSelectUser
}

// Expect sets up expected params for AuthRepository.SelectUser
func (mmSelectUser *mAuthRepositoryMockSelectUser) Expect(ctx context.Context, userLogin *model.UserLogin) *mAuthRepositoryMockSelectUser {
	if mmSelectUser.mock.funcSelectUser != nil {
		mmSelectUser.mock.t.Fatalf("AuthRepositoryMock.SelectUser mock is already set by Set")
	}

	if mmSelectUser.defaultExpectation == nil {
		mmSelectUser.defaultExpectation = &AuthRepositoryMockSelectUserExpectation{}
	}

	if mmSelectUser.defaultExpectation.paramPtrs != nil {
		mmSelectUser.mock.t.Fatalf("AuthRepositoryMock.SelectUser mock is already set by ExpectParams functions")
	}

	mmSelectUser.defaultExpectation.params = &AuthRepositoryMockSelectUserParams{ctx, userLogin}
	mmSelectUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSelectUser.expectations {
		if minimock.Equal(e.params, mmSelectUser.defaultExpectation.params) {
			mmSelectUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelectUser.defaultExpectation.params)
		}
	}

	return mmSelectUser
}

// ExpectCtxParam1 sets up expected param ctx for AuthRepository.SelectUser
func (mmSelectUser *mAuthRepositoryMockSelectUser) ExpectCtxParam1(ctx context.Context) *mAuthRepositoryMockSelectUser {
	if mmSelectUser.mock.funcSelectUser != nil {
		mmSelectUser.mock.t.Fatalf("AuthRepositoryMock.SelectUser mock is already set by Set")
	}

	if mmSelectUser.defaultExpectation == nil {
		mmSelectUser.defaultExpectation = &AuthRepositoryMockSelectUserExpectation{}
	}

	if mmSelectUser.defaultExpectation.params != nil {
		mmSelectUser.mock.t.Fatalf("AuthRepositoryMock.SelectUser mock is already set by Expect")
	}

	if mmSelectUser.defaultExpectation.paramPtrs == nil {
		mmSelectUser.defaultExpectation.paramPtrs = &AuthRepositoryMockSelectUserParamPtrs{}
	}
	mmSelectUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmSelectUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSelectUser
}

// ExpectUserLoginParam2 sets up expected param userLogin for AuthRepository.SelectUser
func (mmSelectUser *mAuthRepositoryMockSelectUser) ExpectUserLoginParam2(userLogin *model.UserLogin) *mAuthRepositoryMockSelectUser {
	if mmSelectUser.mock.funcSelectUser != nil {
		mmSelectUser.mock.t.Fatalf("AuthRepositoryMock.SelectUser mock is already set by Set")
	}

	if mmSelectUser.defaultExpectation == nil {
		mmSelectUser.defaultExpectation = &AuthRepositoryMockSelectUserExpectation{}
	}

	if mmSelectUser.defaultExpectation.params != nil {
		mmSelectUser.mock.t.Fatalf("AuthRepositoryMock.SelectUser mock is already set by Expect")
	}

	if mmSelectUser.defaultExpectation.paramPtrs == nil {
		mmSelectUser.defaultExpectation.paramPtrs = &AuthRepositoryMockSelectUserParamPtrs{}
	}
	mmSelectUser.defaultExpectation.paramPtrs.userLogin = &userLogin
	mmSelectUser.defaultExpectation.expectationOrigins.originUserLogin = minimock.CallerInfo(1)

	return mmSelectUser
}

// Inspect accepts an inspector function that has same arguments as the AuthRepository.SelectUser
func (mmSelectUser *mAuthRepositoryMockSelectUser) Inspect(f func(ctx context.Context, userLogin *model.UserLogin)) *mAuthRepositoryMockSelectUser {
	if mmSelectUser.mock.inspectFuncSelectUser != nil {
		mmSelectUser.mock.t.Fatalf("Inspect function is already set for AuthRepositoryMock.SelectUser")
	}

	mmSelectUser.mock.inspectFuncSelectUser = f

	return mmSelectUser
}

// Return sets up results that will be returned by AuthRepository.SelectUser
func (mmSelectUser *mAuthRepositoryMockSelectUser) Return(u1 model.UserLogin, err error) *AuthRepositoryMock {
	if mmSelectUser.mock.funcSelectUser != nil {
		mmSelectUser.mock.t.Fatalf("AuthRepositoryMock.SelectUser mock is already set by Set")
	}

	if mmSelectUser.defaultExpectation == nil {
		mmSelectUser.defaultExpectation = &AuthRepositoryMockSelectUserExpectation{mock: mmSelectUser.mock}
	}
	mmSelectUser.defaultExpectation.results = &AuthRepositoryMockSelectUserResults{u1, err}
	mmSelectUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSelectUser.mock
}

// Set uses given function f to mock the AuthRepository.SelectUser method
func (mmSelectUser *mAuthRepositoryMockSelectUser) Set(f func(ctx context.Context, userLogin *model.UserLogin) (u1 model.UserLogin, err error)) *AuthRepositoryMock {
	if mmSelectUser.defaultExpectation != nil {
		mmSelectUser.mock.t.Fatalf("Default expectation is already set for the AuthRepository.SelectUser method")
	}

	if len(mmSelectUser.expectations) > 0 {
		mmSelectUser.mock.t.Fatalf("Some expectations are already set for the AuthRepository.SelectUser method")
	}

	mmSelectUser.mock.funcSelectUser = f
	mmSelectUser.mock.funcSelectUserOrigin = minimock.CallerInfo(1)
	return mmSelectUser.mock
}

// When sets expectation for the AuthRepository.SelectUser which will trigger the result defined by the following
// Then helper
func (mmSelectUser *mAuthRepositoryMockSelectUser) When(ctx context.Context, userLogin *model.UserLogin) *AuthRepositoryMockSelectUserExpectation {
	if mmSelectUser.mock.funcSelectUser != nil {
		mmSelectUser.mock.t.Fatalf("AuthRepositoryMock.SelectUser mock is already set by Set")
	}

	expectation := &AuthRepositoryMockSelectUserExpectation{
		mock:               mmSelectUser.mock,
		params:             &AuthRepositoryMockSelectUserParams{ctx, userLogin},
		expectationOrigins: AuthRepositoryMockSelectUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSelectUser.expectations = append(mmSelectUser.expectations, expectation)
	return expectation
}

// Then sets up AuthRepository.SelectUser return parameters for the expectation previously defined by the When method
func (e *AuthRepositoryMockSelectUserExpectation) Then(u1 model.UserLogin, err error) *AuthRepositoryMock {
	e.results = &AuthRepositoryMockSelectUserResults{u1, err}
	return e.mock
}

// Times sets number of times AuthRepository.SelectUser should be invoked
func (mmSelectUser *mAuthRepositoryMockSelectUser) Times(n uint64) *mAuthRepositoryMockSelectUser {
	if n == 0 {
		mmSelectUser.mock.t.Fatalf("Times of AuthRepositoryMock.SelectUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSelectUser.expectedInvocations, n)
	mmSelectUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSelectUser
}

func (mmSelectUser *mAuthRepositoryMockSelectUser) invocationsDone() bool {
	if len(mmSelectUser.expectations) == 0 && mmSelectUser.defaultExpectation == nil && mmSelectUser.mock.funcSelectUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSelectUser.mock.afterSelectUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSelectUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SelectUser implements mm_auth.AuthRepository
func (mmSelectUser *AuthRepositoryMock) SelectUser(ctx context.Context, userLogin *model.UserLogin) (u1 model.UserLogin, err error) {
	mm_atomic.AddUint64(&mmSelectUser.beforeSelectUserCounter, 1)
	defer mm_atomic.AddUint64(&mmSelectUser.afterSelectUserCounter, 1)

	mmSelectUser.t.Helper()

	if mmSelectUser.inspectFuncSelectUser != nil {
		mmSelectUser.inspectFuncSelectUser(ctx, userLogin)
	}

	mm_params := AuthRepositoryMockSelectUserParams{ctx, userLogin}

	// Record call args
	mmSelectUser.SelectUserMock.mutex.Lock()
	mmSelectUser.SelectUserMock.callArgs = append(mmSelectUser.SelectUserMock.callArgs, &mm_params)
	mmSelectUser.SelectUserMock.mutex.Unlock()

	for _, e := range mmSelectUser.SelectUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmSelectUser.SelectUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelectUser.SelectUserMock.defaultExpectation.Counter, 1)
		mm_want := mmSelectUser.SelectUserMock.defaultExpectation.params
		mm_want_ptrs := mmSelectUser.SelectUserMock.defaultExpectation.paramPtrs

		mm_got := AuthRepositoryMockSelectUserParams{ctx, userLogin}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSelectUser.t.Errorf("AuthRepositoryMock.SelectUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectUser.SelectUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userLogin != nil && !minimock.Equal(*mm_want_ptrs.userLogin, mm_got.userLogin) {
				mmSelectUser.t.Errorf("AuthRepositoryMock.SelectUser got unexpected parameter userLogin, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSelectUser.SelectUserMock.defaultExpectation.expectationOrigins.originUserLogin, *mm_want_ptrs.userLogin, mm_got.userLogin, minimock.Diff(*mm_want_ptrs.userLogin, mm_got.userLogin))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelectUser.t.Errorf("AuthRepositoryMock.SelectUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSelectUser.SelectUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelectUser.SelectUserMock.defaultExpectation.results
		if mm_results == nil {
			mmSelectUser.t.Fatal("No results are set for the AuthRepositoryMock.SelectUser")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmSelectUser.funcSelectUser != nil {
		return mmSelectUser.funcSelectUser(ctx, userLogin)
	}
	mmSelectUser.t.Fatalf("Unexpected call to AuthRepositoryMock.SelectUser. %v %v", ctx, userLogin)
	return
}

// SelectUserAfterCounter returns a count of finished AuthRepositoryMock.SelectUser invocations
func (mmSelectUser *AuthRepositoryMock) SelectUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectUser.afterSelectUserCounter)
}

// SelectUserBeforeCounter returns a count of AuthRepositoryMock.SelectUser invocations
func (mmSelectUser *AuthRepositoryMock) SelectUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelectUser.beforeSelectUserCounter)
}

// Calls returns a list of arguments used in each call to AuthRepositoryMock.SelectUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelectUser *mAuthRepositoryMockSelectUser) Calls() []*AuthRepositoryMockSelectUserParams {
	mmSelectUser.mutex.RLock()

	argCopy := make([]*AuthRepositoryMockSelectUserParams, len(mmSelectUser.callArgs))
	copy(argCopy, mmSelectUser.callArgs)

	mmSelectUser.mutex.RUnlock()

	return argCopy
}

// MinimockSelectUserDone returns true if the count of the SelectUser invocations corresponds
// the number of defined expectations
func (m *AuthRepositoryMock) MinimockSelectUserDone() bool {
	if m.SelectUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SelectUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SelectUserMock.invocationsDone()
}

// MinimockSelectUserInspect logs each unmet expectation
func (m *AuthRepositoryMock) MinimockSelectUserInspect() {
	for _, e := range m.SelectUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthRepositoryMock.SelectUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSelectUserCounter := mm_atomic.LoadUint64(&m.afterSelectUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SelectUserMock.defaultExpectation != nil && afterSelectUserCounter < 1 {
		if m.SelectUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthRepositoryMock.SelectUser at\n%s", m.SelectUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthRepositoryMock.SelectUser at\n%s with params: %#v", m.SelectUserMock.defaultExpectation.expectationOrigins.origin, *m.SelectUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelectUser != nil && afterSelectUserCounter < 1 {
		m.t.Errorf("Expected call to AuthRepositoryMock.SelectUser at\n%s", m.funcSelectUserOrigin)
	}

	if !m.SelectUserMock.invocationsDone() && afterSelectUserCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthRepositoryMock.SelectUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SelectUserMock.expectedInvocations), m.SelectUserMock.expectedInvocationsOrigin, afterSelectUserCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AuthRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCheckLoginUniqueInspect()

			m.MinimockCreateUserInspect()

			m.MinimockSelectUserInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AuthRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AuthRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCheckLoginUniqueDone() &&
		m.MinimockCreateUserDone() &&
		m.MinimockSelectUserDone()
}
