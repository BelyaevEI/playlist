// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/BelyaevEI/playlist/internal/repository/playlist.PlaylistRepository -o playlist_repository_minimock.go -n PlaylistRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/BelyaevEI/playlist/internal/model"
	"github.com/gojuno/minimock/v3"
)

// PlaylistRepositoryMock implements mm_playlist.PlaylistRepository
type PlaylistRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddSong          func(ctx context.Context, song *model.SongRequest) (err error)
	funcAddSongOrigin    string
	inspectFuncAddSong   func(ctx context.Context, song *model.SongRequest)
	afterAddSongCounter  uint64
	beforeAddSongCounter uint64
	AddSongMock          mPlaylistRepositoryMockAddSong

	funcDeleteSong          func(ctx context.Context, song *model.SongRequest) (err error)
	funcDeleteSongOrigin    string
	inspectFuncDeleteSong   func(ctx context.Context, song *model.SongRequest)
	afterDeleteSongCounter  uint64
	beforeDeleteSongCounter uint64
	DeleteSongMock          mPlaylistRepositoryMockDeleteSong

	funcGetFirstSongOfUser          func(ctx context.Context, login string) (s1 model.Song, err error)
	funcGetFirstSongOfUserOrigin    string
	inspectFuncGetFirstSongOfUser   func(ctx context.Context, login string)
	afterGetFirstSongOfUserCounter  uint64
	beforeGetFirstSongOfUserCounter uint64
	GetFirstSongOfUserMock          mPlaylistRepositoryMockGetFirstSongOfUser

	funcGetNextSongOfUser          func(ctx context.Context, login string, curID int64, nextID int64) (s1 model.Song, err error)
	funcGetNextSongOfUserOrigin    string
	inspectFuncGetNextSongOfUser   func(ctx context.Context, login string, curID int64, nextID int64)
	afterGetNextSongOfUserCounter  uint64
	beforeGetNextSongOfUserCounter uint64
	GetNextSongOfUserMock          mPlaylistRepositoryMockGetNextSongOfUser

	funcGetPrevSongOfUser          func(ctx context.Context, login string, currID int64, prevID int64) (s1 model.Song, err error)
	funcGetPrevSongOfUserOrigin    string
	inspectFuncGetPrevSongOfUser   func(ctx context.Context, login string, currID int64, prevID int64)
	afterGetPrevSongOfUserCounter  uint64
	beforeGetPrevSongOfUserCounter uint64
	GetPrevSongOfUserMock          mPlaylistRepositoryMockGetPrevSongOfUser
}

// NewPlaylistRepositoryMock returns a mock for mm_playlist.PlaylistRepository
func NewPlaylistRepositoryMock(t minimock.Tester) *PlaylistRepositoryMock {
	m := &PlaylistRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddSongMock = mPlaylistRepositoryMockAddSong{mock: m}
	m.AddSongMock.callArgs = []*PlaylistRepositoryMockAddSongParams{}

	m.DeleteSongMock = mPlaylistRepositoryMockDeleteSong{mock: m}
	m.DeleteSongMock.callArgs = []*PlaylistRepositoryMockDeleteSongParams{}

	m.GetFirstSongOfUserMock = mPlaylistRepositoryMockGetFirstSongOfUser{mock: m}
	m.GetFirstSongOfUserMock.callArgs = []*PlaylistRepositoryMockGetFirstSongOfUserParams{}

	m.GetNextSongOfUserMock = mPlaylistRepositoryMockGetNextSongOfUser{mock: m}
	m.GetNextSongOfUserMock.callArgs = []*PlaylistRepositoryMockGetNextSongOfUserParams{}

	m.GetPrevSongOfUserMock = mPlaylistRepositoryMockGetPrevSongOfUser{mock: m}
	m.GetPrevSongOfUserMock.callArgs = []*PlaylistRepositoryMockGetPrevSongOfUserParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mPlaylistRepositoryMockAddSong struct {
	optional           bool
	mock               *PlaylistRepositoryMock
	defaultExpectation *PlaylistRepositoryMockAddSongExpectation
	expectations       []*PlaylistRepositoryMockAddSongExpectation

	callArgs []*PlaylistRepositoryMockAddSongParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PlaylistRepositoryMockAddSongExpectation specifies expectation struct of the PlaylistRepository.AddSong
type PlaylistRepositoryMockAddSongExpectation struct {
	mock               *PlaylistRepositoryMock
	params             *PlaylistRepositoryMockAddSongParams
	paramPtrs          *PlaylistRepositoryMockAddSongParamPtrs
	expectationOrigins PlaylistRepositoryMockAddSongExpectationOrigins
	results            *PlaylistRepositoryMockAddSongResults
	returnOrigin       string
	Counter            uint64
}

// PlaylistRepositoryMockAddSongParams contains parameters of the PlaylistRepository.AddSong
type PlaylistRepositoryMockAddSongParams struct {
	ctx  context.Context
	song *model.SongRequest
}

// PlaylistRepositoryMockAddSongParamPtrs contains pointers to parameters of the PlaylistRepository.AddSong
type PlaylistRepositoryMockAddSongParamPtrs struct {
	ctx  *context.Context
	song **model.SongRequest
}

// PlaylistRepositoryMockAddSongResults contains results of the PlaylistRepository.AddSong
type PlaylistRepositoryMockAddSongResults struct {
	err error
}

// PlaylistRepositoryMockAddSongOrigins contains origins of expectations of the PlaylistRepository.AddSong
type PlaylistRepositoryMockAddSongExpectationOrigins struct {
	origin     string
	originCtx  string
	originSong string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddSong *mPlaylistRepositoryMockAddSong) Optional() *mPlaylistRepositoryMockAddSong {
	mmAddSong.optional = true
	return mmAddSong
}

// Expect sets up expected params for PlaylistRepository.AddSong
func (mmAddSong *mPlaylistRepositoryMockAddSong) Expect(ctx context.Context, song *model.SongRequest) *mPlaylistRepositoryMockAddSong {
	if mmAddSong.mock.funcAddSong != nil {
		mmAddSong.mock.t.Fatalf("PlaylistRepositoryMock.AddSong mock is already set by Set")
	}

	if mmAddSong.defaultExpectation == nil {
		mmAddSong.defaultExpectation = &PlaylistRepositoryMockAddSongExpectation{}
	}

	if mmAddSong.defaultExpectation.paramPtrs != nil {
		mmAddSong.mock.t.Fatalf("PlaylistRepositoryMock.AddSong mock is already set by ExpectParams functions")
	}

	mmAddSong.defaultExpectation.params = &PlaylistRepositoryMockAddSongParams{ctx, song}
	mmAddSong.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddSong.expectations {
		if minimock.Equal(e.params, mmAddSong.defaultExpectation.params) {
			mmAddSong.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddSong.defaultExpectation.params)
		}
	}

	return mmAddSong
}

// ExpectCtxParam1 sets up expected param ctx for PlaylistRepository.AddSong
func (mmAddSong *mPlaylistRepositoryMockAddSong) ExpectCtxParam1(ctx context.Context) *mPlaylistRepositoryMockAddSong {
	if mmAddSong.mock.funcAddSong != nil {
		mmAddSong.mock.t.Fatalf("PlaylistRepositoryMock.AddSong mock is already set by Set")
	}

	if mmAddSong.defaultExpectation == nil {
		mmAddSong.defaultExpectation = &PlaylistRepositoryMockAddSongExpectation{}
	}

	if mmAddSong.defaultExpectation.params != nil {
		mmAddSong.mock.t.Fatalf("PlaylistRepositoryMock.AddSong mock is already set by Expect")
	}

	if mmAddSong.defaultExpectation.paramPtrs == nil {
		mmAddSong.defaultExpectation.paramPtrs = &PlaylistRepositoryMockAddSongParamPtrs{}
	}
	mmAddSong.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddSong.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddSong
}

// ExpectSongParam2 sets up expected param song for PlaylistRepository.AddSong
func (mmAddSong *mPlaylistRepositoryMockAddSong) ExpectSongParam2(song *model.SongRequest) *mPlaylistRepositoryMockAddSong {
	if mmAddSong.mock.funcAddSong != nil {
		mmAddSong.mock.t.Fatalf("PlaylistRepositoryMock.AddSong mock is already set by Set")
	}

	if mmAddSong.defaultExpectation == nil {
		mmAddSong.defaultExpectation = &PlaylistRepositoryMockAddSongExpectation{}
	}

	if mmAddSong.defaultExpectation.params != nil {
		mmAddSong.mock.t.Fatalf("PlaylistRepositoryMock.AddSong mock is already set by Expect")
	}

	if mmAddSong.defaultExpectation.paramPtrs == nil {
		mmAddSong.defaultExpectation.paramPtrs = &PlaylistRepositoryMockAddSongParamPtrs{}
	}
	mmAddSong.defaultExpectation.paramPtrs.song = &song
	mmAddSong.defaultExpectation.expectationOrigins.originSong = minimock.CallerInfo(1)

	return mmAddSong
}

// Inspect accepts an inspector function that has same arguments as the PlaylistRepository.AddSong
func (mmAddSong *mPlaylistRepositoryMockAddSong) Inspect(f func(ctx context.Context, song *model.SongRequest)) *mPlaylistRepositoryMockAddSong {
	if mmAddSong.mock.inspectFuncAddSong != nil {
		mmAddSong.mock.t.Fatalf("Inspect function is already set for PlaylistRepositoryMock.AddSong")
	}

	mmAddSong.mock.inspectFuncAddSong = f

	return mmAddSong
}

// Return sets up results that will be returned by PlaylistRepository.AddSong
func (mmAddSong *mPlaylistRepositoryMockAddSong) Return(err error) *PlaylistRepositoryMock {
	if mmAddSong.mock.funcAddSong != nil {
		mmAddSong.mock.t.Fatalf("PlaylistRepositoryMock.AddSong mock is already set by Set")
	}

	if mmAddSong.defaultExpectation == nil {
		mmAddSong.defaultExpectation = &PlaylistRepositoryMockAddSongExpectation{mock: mmAddSong.mock}
	}
	mmAddSong.defaultExpectation.results = &PlaylistRepositoryMockAddSongResults{err}
	mmAddSong.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddSong.mock
}

// Set uses given function f to mock the PlaylistRepository.AddSong method
func (mmAddSong *mPlaylistRepositoryMockAddSong) Set(f func(ctx context.Context, song *model.SongRequest) (err error)) *PlaylistRepositoryMock {
	if mmAddSong.defaultExpectation != nil {
		mmAddSong.mock.t.Fatalf("Default expectation is already set for the PlaylistRepository.AddSong method")
	}

	if len(mmAddSong.expectations) > 0 {
		mmAddSong.mock.t.Fatalf("Some expectations are already set for the PlaylistRepository.AddSong method")
	}

	mmAddSong.mock.funcAddSong = f
	mmAddSong.mock.funcAddSongOrigin = minimock.CallerInfo(1)
	return mmAddSong.mock
}

// When sets expectation for the PlaylistRepository.AddSong which will trigger the result defined by the following
// Then helper
func (mmAddSong *mPlaylistRepositoryMockAddSong) When(ctx context.Context, song *model.SongRequest) *PlaylistRepositoryMockAddSongExpectation {
	if mmAddSong.mock.funcAddSong != nil {
		mmAddSong.mock.t.Fatalf("PlaylistRepositoryMock.AddSong mock is already set by Set")
	}

	expectation := &PlaylistRepositoryMockAddSongExpectation{
		mock:               mmAddSong.mock,
		params:             &PlaylistRepositoryMockAddSongParams{ctx, song},
		expectationOrigins: PlaylistRepositoryMockAddSongExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddSong.expectations = append(mmAddSong.expectations, expectation)
	return expectation
}

// Then sets up PlaylistRepository.AddSong return parameters for the expectation previously defined by the When method
func (e *PlaylistRepositoryMockAddSongExpectation) Then(err error) *PlaylistRepositoryMock {
	e.results = &PlaylistRepositoryMockAddSongResults{err}
	return e.mock
}

// Times sets number of times PlaylistRepository.AddSong should be invoked
func (mmAddSong *mPlaylistRepositoryMockAddSong) Times(n uint64) *mPlaylistRepositoryMockAddSong {
	if n == 0 {
		mmAddSong.mock.t.Fatalf("Times of PlaylistRepositoryMock.AddSong mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddSong.expectedInvocations, n)
	mmAddSong.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddSong
}

func (mmAddSong *mPlaylistRepositoryMockAddSong) invocationsDone() bool {
	if len(mmAddSong.expectations) == 0 && mmAddSong.defaultExpectation == nil && mmAddSong.mock.funcAddSong == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddSong.mock.afterAddSongCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddSong.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddSong implements mm_playlist.PlaylistRepository
func (mmAddSong *PlaylistRepositoryMock) AddSong(ctx context.Context, song *model.SongRequest) (err error) {
	mm_atomic.AddUint64(&mmAddSong.beforeAddSongCounter, 1)
	defer mm_atomic.AddUint64(&mmAddSong.afterAddSongCounter, 1)

	mmAddSong.t.Helper()

	if mmAddSong.inspectFuncAddSong != nil {
		mmAddSong.inspectFuncAddSong(ctx, song)
	}

	mm_params := PlaylistRepositoryMockAddSongParams{ctx, song}

	// Record call args
	mmAddSong.AddSongMock.mutex.Lock()
	mmAddSong.AddSongMock.callArgs = append(mmAddSong.AddSongMock.callArgs, &mm_params)
	mmAddSong.AddSongMock.mutex.Unlock()

	for _, e := range mmAddSong.AddSongMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddSong.AddSongMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddSong.AddSongMock.defaultExpectation.Counter, 1)
		mm_want := mmAddSong.AddSongMock.defaultExpectation.params
		mm_want_ptrs := mmAddSong.AddSongMock.defaultExpectation.paramPtrs

		mm_got := PlaylistRepositoryMockAddSongParams{ctx, song}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddSong.t.Errorf("PlaylistRepositoryMock.AddSong got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddSong.AddSongMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.song != nil && !minimock.Equal(*mm_want_ptrs.song, mm_got.song) {
				mmAddSong.t.Errorf("PlaylistRepositoryMock.AddSong got unexpected parameter song, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddSong.AddSongMock.defaultExpectation.expectationOrigins.originSong, *mm_want_ptrs.song, mm_got.song, minimock.Diff(*mm_want_ptrs.song, mm_got.song))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddSong.t.Errorf("PlaylistRepositoryMock.AddSong got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddSong.AddSongMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddSong.AddSongMock.defaultExpectation.results
		if mm_results == nil {
			mmAddSong.t.Fatal("No results are set for the PlaylistRepositoryMock.AddSong")
		}
		return (*mm_results).err
	}
	if mmAddSong.funcAddSong != nil {
		return mmAddSong.funcAddSong(ctx, song)
	}
	mmAddSong.t.Fatalf("Unexpected call to PlaylistRepositoryMock.AddSong. %v %v", ctx, song)
	return
}

// AddSongAfterCounter returns a count of finished PlaylistRepositoryMock.AddSong invocations
func (mmAddSong *PlaylistRepositoryMock) AddSongAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddSong.afterAddSongCounter)
}

// AddSongBeforeCounter returns a count of PlaylistRepositoryMock.AddSong invocations
func (mmAddSong *PlaylistRepositoryMock) AddSongBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddSong.beforeAddSongCounter)
}

// Calls returns a list of arguments used in each call to PlaylistRepositoryMock.AddSong.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddSong *mPlaylistRepositoryMockAddSong) Calls() []*PlaylistRepositoryMockAddSongParams {
	mmAddSong.mutex.RLock()

	argCopy := make([]*PlaylistRepositoryMockAddSongParams, len(mmAddSong.callArgs))
	copy(argCopy, mmAddSong.callArgs)

	mmAddSong.mutex.RUnlock()

	return argCopy
}

// MinimockAddSongDone returns true if the count of the AddSong invocations corresponds
// the number of defined expectations
func (m *PlaylistRepositoryMock) MinimockAddSongDone() bool {
	if m.AddSongMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddSongMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddSongMock.invocationsDone()
}

// MinimockAddSongInspect logs each unmet expectation
func (m *PlaylistRepositoryMock) MinimockAddSongInspect() {
	for _, e := range m.AddSongMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PlaylistRepositoryMock.AddSong at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddSongCounter := mm_atomic.LoadUint64(&m.afterAddSongCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddSongMock.defaultExpectation != nil && afterAddSongCounter < 1 {
		if m.AddSongMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PlaylistRepositoryMock.AddSong at\n%s", m.AddSongMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PlaylistRepositoryMock.AddSong at\n%s with params: %#v", m.AddSongMock.defaultExpectation.expectationOrigins.origin, *m.AddSongMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddSong != nil && afterAddSongCounter < 1 {
		m.t.Errorf("Expected call to PlaylistRepositoryMock.AddSong at\n%s", m.funcAddSongOrigin)
	}

	if !m.AddSongMock.invocationsDone() && afterAddSongCounter > 0 {
		m.t.Errorf("Expected %d calls to PlaylistRepositoryMock.AddSong at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddSongMock.expectedInvocations), m.AddSongMock.expectedInvocationsOrigin, afterAddSongCounter)
	}
}

type mPlaylistRepositoryMockDeleteSong struct {
	optional           bool
	mock               *PlaylistRepositoryMock
	defaultExpectation *PlaylistRepositoryMockDeleteSongExpectation
	expectations       []*PlaylistRepositoryMockDeleteSongExpectation

	callArgs []*PlaylistRepositoryMockDeleteSongParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PlaylistRepositoryMockDeleteSongExpectation specifies expectation struct of the PlaylistRepository.DeleteSong
type PlaylistRepositoryMockDeleteSongExpectation struct {
	mock               *PlaylistRepositoryMock
	params             *PlaylistRepositoryMockDeleteSongParams
	paramPtrs          *PlaylistRepositoryMockDeleteSongParamPtrs
	expectationOrigins PlaylistRepositoryMockDeleteSongExpectationOrigins
	results            *PlaylistRepositoryMockDeleteSongResults
	returnOrigin       string
	Counter            uint64
}

// PlaylistRepositoryMockDeleteSongParams contains parameters of the PlaylistRepository.DeleteSong
type PlaylistRepositoryMockDeleteSongParams struct {
	ctx  context.Context
	song *model.SongRequest
}

// PlaylistRepositoryMockDeleteSongParamPtrs contains pointers to parameters of the PlaylistRepository.DeleteSong
type PlaylistRepositoryMockDeleteSongParamPtrs struct {
	ctx  *context.Context
	song **model.SongRequest
}

// PlaylistRepositoryMockDeleteSongResults contains results of the PlaylistRepository.DeleteSong
type PlaylistRepositoryMockDeleteSongResults struct {
	err error
}

// PlaylistRepositoryMockDeleteSongOrigins contains origins of expectations of the PlaylistRepository.DeleteSong
type PlaylistRepositoryMockDeleteSongExpectationOrigins struct {
	origin     string
	originCtx  string
	originSong string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteSong *mPlaylistRepositoryMockDeleteSong) Optional() *mPlaylistRepositoryMockDeleteSong {
	mmDeleteSong.optional = true
	return mmDeleteSong
}

// Expect sets up expected params for PlaylistRepository.DeleteSong
func (mmDeleteSong *mPlaylistRepositoryMockDeleteSong) Expect(ctx context.Context, song *model.SongRequest) *mPlaylistRepositoryMockDeleteSong {
	if mmDeleteSong.mock.funcDeleteSong != nil {
		mmDeleteSong.mock.t.Fatalf("PlaylistRepositoryMock.DeleteSong mock is already set by Set")
	}

	if mmDeleteSong.defaultExpectation == nil {
		mmDeleteSong.defaultExpectation = &PlaylistRepositoryMockDeleteSongExpectation{}
	}

	if mmDeleteSong.defaultExpectation.paramPtrs != nil {
		mmDeleteSong.mock.t.Fatalf("PlaylistRepositoryMock.DeleteSong mock is already set by ExpectParams functions")
	}

	mmDeleteSong.defaultExpectation.params = &PlaylistRepositoryMockDeleteSongParams{ctx, song}
	mmDeleteSong.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteSong.expectations {
		if minimock.Equal(e.params, mmDeleteSong.defaultExpectation.params) {
			mmDeleteSong.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteSong.defaultExpectation.params)
		}
	}

	return mmDeleteSong
}

// ExpectCtxParam1 sets up expected param ctx for PlaylistRepository.DeleteSong
func (mmDeleteSong *mPlaylistRepositoryMockDeleteSong) ExpectCtxParam1(ctx context.Context) *mPlaylistRepositoryMockDeleteSong {
	if mmDeleteSong.mock.funcDeleteSong != nil {
		mmDeleteSong.mock.t.Fatalf("PlaylistRepositoryMock.DeleteSong mock is already set by Set")
	}

	if mmDeleteSong.defaultExpectation == nil {
		mmDeleteSong.defaultExpectation = &PlaylistRepositoryMockDeleteSongExpectation{}
	}

	if mmDeleteSong.defaultExpectation.params != nil {
		mmDeleteSong.mock.t.Fatalf("PlaylistRepositoryMock.DeleteSong mock is already set by Expect")
	}

	if mmDeleteSong.defaultExpectation.paramPtrs == nil {
		mmDeleteSong.defaultExpectation.paramPtrs = &PlaylistRepositoryMockDeleteSongParamPtrs{}
	}
	mmDeleteSong.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteSong.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteSong
}

// ExpectSongParam2 sets up expected param song for PlaylistRepository.DeleteSong
func (mmDeleteSong *mPlaylistRepositoryMockDeleteSong) ExpectSongParam2(song *model.SongRequest) *mPlaylistRepositoryMockDeleteSong {
	if mmDeleteSong.mock.funcDeleteSong != nil {
		mmDeleteSong.mock.t.Fatalf("PlaylistRepositoryMock.DeleteSong mock is already set by Set")
	}

	if mmDeleteSong.defaultExpectation == nil {
		mmDeleteSong.defaultExpectation = &PlaylistRepositoryMockDeleteSongExpectation{}
	}

	if mmDeleteSong.defaultExpectation.params != nil {
		mmDeleteSong.mock.t.Fatalf("PlaylistRepositoryMock.DeleteSong mock is already set by Expect")
	}

	if mmDeleteSong.defaultExpectation.paramPtrs == nil {
		mmDeleteSong.defaultExpectation.paramPtrs = &PlaylistRepositoryMockDeleteSongParamPtrs{}
	}
	mmDeleteSong.defaultExpectation.paramPtrs.song = &song
	mmDeleteSong.defaultExpectation.expectationOrigins.originSong = minimock.CallerInfo(1)

	return mmDeleteSong
}

// Inspect accepts an inspector function that has same arguments as the PlaylistRepository.DeleteSong
func (mmDeleteSong *mPlaylistRepositoryMockDeleteSong) Inspect(f func(ctx context.Context, song *model.SongRequest)) *mPlaylistRepositoryMockDeleteSong {
	if mmDeleteSong.mock.inspectFuncDeleteSong != nil {
		mmDeleteSong.mock.t.Fatalf("Inspect function is already set for PlaylistRepositoryMock.DeleteSong")
	}

	mmDeleteSong.mock.inspectFuncDeleteSong = f

	return mmDeleteSong
}

// Return sets up results that will be returned by PlaylistRepository.DeleteSong
func (mmDeleteSong *mPlaylistRepositoryMockDeleteSong) Return(err error) *PlaylistRepositoryMock {
	if mmDeleteSong.mock.funcDeleteSong != nil {
		mmDeleteSong.mock.t.Fatalf("PlaylistRepositoryMock.DeleteSong mock is already set by Set")
	}

	if mmDeleteSong.defaultExpectation == nil {
		mmDeleteSong.defaultExpectation = &PlaylistRepositoryMockDeleteSongExpectation{mock: mmDeleteSong.mock}
	}
	mmDeleteSong.defaultExpectation.results = &PlaylistRepositoryMockDeleteSongResults{err}
	mmDeleteSong.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteSong.mock
}

// Set uses given function f to mock the PlaylistRepository.DeleteSong method
func (mmDeleteSong *mPlaylistRepositoryMockDeleteSong) Set(f func(ctx context.Context, song *model.SongRequest) (err error)) *PlaylistRepositoryMock {
	if mmDeleteSong.defaultExpectation != nil {
		mmDeleteSong.mock.t.Fatalf("Default expectation is already set for the PlaylistRepository.DeleteSong method")
	}

	if len(mmDeleteSong.expectations) > 0 {
		mmDeleteSong.mock.t.Fatalf("Some expectations are already set for the PlaylistRepository.DeleteSong method")
	}

	mmDeleteSong.mock.funcDeleteSong = f
	mmDeleteSong.mock.funcDeleteSongOrigin = minimock.CallerInfo(1)
	return mmDeleteSong.mock
}

// When sets expectation for the PlaylistRepository.DeleteSong which will trigger the result defined by the following
// Then helper
func (mmDeleteSong *mPlaylistRepositoryMockDeleteSong) When(ctx context.Context, song *model.SongRequest) *PlaylistRepositoryMockDeleteSongExpectation {
	if mmDeleteSong.mock.funcDeleteSong != nil {
		mmDeleteSong.mock.t.Fatalf("PlaylistRepositoryMock.DeleteSong mock is already set by Set")
	}

	expectation := &PlaylistRepositoryMockDeleteSongExpectation{
		mock:               mmDeleteSong.mock,
		params:             &PlaylistRepositoryMockDeleteSongParams{ctx, song},
		expectationOrigins: PlaylistRepositoryMockDeleteSongExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteSong.expectations = append(mmDeleteSong.expectations, expectation)
	return expectation
}

// Then sets up PlaylistRepository.DeleteSong return parameters for the expectation previously defined by the When method
func (e *PlaylistRepositoryMockDeleteSongExpectation) Then(err error) *PlaylistRepositoryMock {
	e.results = &PlaylistRepositoryMockDeleteSongResults{err}
	return e.mock
}

// Times sets number of times PlaylistRepository.DeleteSong should be invoked
func (mmDeleteSong *mPlaylistRepositoryMockDeleteSong) Times(n uint64) *mPlaylistRepositoryMockDeleteSong {
	if n == 0 {
		mmDeleteSong.mock.t.Fatalf("Times of PlaylistRepositoryMock.DeleteSong mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteSong.expectedInvocations, n)
	mmDeleteSong.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteSong
}

func (mmDeleteSong *mPlaylistRepositoryMockDeleteSong) invocationsDone() bool {
	if len(mmDeleteSong.expectations) == 0 && mmDeleteSong.defaultExpectation == nil && mmDeleteSong.mock.funcDeleteSong == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteSong.mock.afterDeleteSongCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteSong.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteSong implements mm_playlist.PlaylistRepository
func (mmDeleteSong *PlaylistRepositoryMock) DeleteSong(ctx context.Context, song *model.SongRequest) (err error) {
	mm_atomic.AddUint64(&mmDeleteSong.beforeDeleteSongCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteSong.afterDeleteSongCounter, 1)

	mmDeleteSong.t.Helper()

	if mmDeleteSong.inspectFuncDeleteSong != nil {
		mmDeleteSong.inspectFuncDeleteSong(ctx, song)
	}

	mm_params := PlaylistRepositoryMockDeleteSongParams{ctx, song}

	// Record call args
	mmDeleteSong.DeleteSongMock.mutex.Lock()
	mmDeleteSong.DeleteSongMock.callArgs = append(mmDeleteSong.DeleteSongMock.callArgs, &mm_params)
	mmDeleteSong.DeleteSongMock.mutex.Unlock()

	for _, e := range mmDeleteSong.DeleteSongMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteSong.DeleteSongMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteSong.DeleteSongMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteSong.DeleteSongMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteSong.DeleteSongMock.defaultExpectation.paramPtrs

		mm_got := PlaylistRepositoryMockDeleteSongParams{ctx, song}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteSong.t.Errorf("PlaylistRepositoryMock.DeleteSong got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteSong.DeleteSongMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.song != nil && !minimock.Equal(*mm_want_ptrs.song, mm_got.song) {
				mmDeleteSong.t.Errorf("PlaylistRepositoryMock.DeleteSong got unexpected parameter song, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteSong.DeleteSongMock.defaultExpectation.expectationOrigins.originSong, *mm_want_ptrs.song, mm_got.song, minimock.Diff(*mm_want_ptrs.song, mm_got.song))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteSong.t.Errorf("PlaylistRepositoryMock.DeleteSong got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteSong.DeleteSongMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteSong.DeleteSongMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteSong.t.Fatal("No results are set for the PlaylistRepositoryMock.DeleteSong")
		}
		return (*mm_results).err
	}
	if mmDeleteSong.funcDeleteSong != nil {
		return mmDeleteSong.funcDeleteSong(ctx, song)
	}
	mmDeleteSong.t.Fatalf("Unexpected call to PlaylistRepositoryMock.DeleteSong. %v %v", ctx, song)
	return
}

// DeleteSongAfterCounter returns a count of finished PlaylistRepositoryMock.DeleteSong invocations
func (mmDeleteSong *PlaylistRepositoryMock) DeleteSongAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSong.afterDeleteSongCounter)
}

// DeleteSongBeforeCounter returns a count of PlaylistRepositoryMock.DeleteSong invocations
func (mmDeleteSong *PlaylistRepositoryMock) DeleteSongBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSong.beforeDeleteSongCounter)
}

// Calls returns a list of arguments used in each call to PlaylistRepositoryMock.DeleteSong.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteSong *mPlaylistRepositoryMockDeleteSong) Calls() []*PlaylistRepositoryMockDeleteSongParams {
	mmDeleteSong.mutex.RLock()

	argCopy := make([]*PlaylistRepositoryMockDeleteSongParams, len(mmDeleteSong.callArgs))
	copy(argCopy, mmDeleteSong.callArgs)

	mmDeleteSong.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteSongDone returns true if the count of the DeleteSong invocations corresponds
// the number of defined expectations
func (m *PlaylistRepositoryMock) MinimockDeleteSongDone() bool {
	if m.DeleteSongMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteSongMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteSongMock.invocationsDone()
}

// MinimockDeleteSongInspect logs each unmet expectation
func (m *PlaylistRepositoryMock) MinimockDeleteSongInspect() {
	for _, e := range m.DeleteSongMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PlaylistRepositoryMock.DeleteSong at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteSongCounter := mm_atomic.LoadUint64(&m.afterDeleteSongCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteSongMock.defaultExpectation != nil && afterDeleteSongCounter < 1 {
		if m.DeleteSongMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PlaylistRepositoryMock.DeleteSong at\n%s", m.DeleteSongMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PlaylistRepositoryMock.DeleteSong at\n%s with params: %#v", m.DeleteSongMock.defaultExpectation.expectationOrigins.origin, *m.DeleteSongMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteSong != nil && afterDeleteSongCounter < 1 {
		m.t.Errorf("Expected call to PlaylistRepositoryMock.DeleteSong at\n%s", m.funcDeleteSongOrigin)
	}

	if !m.DeleteSongMock.invocationsDone() && afterDeleteSongCounter > 0 {
		m.t.Errorf("Expected %d calls to PlaylistRepositoryMock.DeleteSong at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteSongMock.expectedInvocations), m.DeleteSongMock.expectedInvocationsOrigin, afterDeleteSongCounter)
	}
}

type mPlaylistRepositoryMockGetFirstSongOfUser struct {
	optional           bool
	mock               *PlaylistRepositoryMock
	defaultExpectation *PlaylistRepositoryMockGetFirstSongOfUserExpectation
	expectations       []*PlaylistRepositoryMockGetFirstSongOfUserExpectation

	callArgs []*PlaylistRepositoryMockGetFirstSongOfUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PlaylistRepositoryMockGetFirstSongOfUserExpectation specifies expectation struct of the PlaylistRepository.GetFirstSongOfUser
type PlaylistRepositoryMockGetFirstSongOfUserExpectation struct {
	mock               *PlaylistRepositoryMock
	params             *PlaylistRepositoryMockGetFirstSongOfUserParams
	paramPtrs          *PlaylistRepositoryMockGetFirstSongOfUserParamPtrs
	expectationOrigins PlaylistRepositoryMockGetFirstSongOfUserExpectationOrigins
	results            *PlaylistRepositoryMockGetFirstSongOfUserResults
	returnOrigin       string
	Counter            uint64
}

// PlaylistRepositoryMockGetFirstSongOfUserParams contains parameters of the PlaylistRepository.GetFirstSongOfUser
type PlaylistRepositoryMockGetFirstSongOfUserParams struct {
	ctx   context.Context
	login string
}

// PlaylistRepositoryMockGetFirstSongOfUserParamPtrs contains pointers to parameters of the PlaylistRepository.GetFirstSongOfUser
type PlaylistRepositoryMockGetFirstSongOfUserParamPtrs struct {
	ctx   *context.Context
	login *string
}

// PlaylistRepositoryMockGetFirstSongOfUserResults contains results of the PlaylistRepository.GetFirstSongOfUser
type PlaylistRepositoryMockGetFirstSongOfUserResults struct {
	s1  model.Song
	err error
}

// PlaylistRepositoryMockGetFirstSongOfUserOrigins contains origins of expectations of the PlaylistRepository.GetFirstSongOfUser
type PlaylistRepositoryMockGetFirstSongOfUserExpectationOrigins struct {
	origin      string
	originCtx   string
	originLogin string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetFirstSongOfUser *mPlaylistRepositoryMockGetFirstSongOfUser) Optional() *mPlaylistRepositoryMockGetFirstSongOfUser {
	mmGetFirstSongOfUser.optional = true
	return mmGetFirstSongOfUser
}

// Expect sets up expected params for PlaylistRepository.GetFirstSongOfUser
func (mmGetFirstSongOfUser *mPlaylistRepositoryMockGetFirstSongOfUser) Expect(ctx context.Context, login string) *mPlaylistRepositoryMockGetFirstSongOfUser {
	if mmGetFirstSongOfUser.mock.funcGetFirstSongOfUser != nil {
		mmGetFirstSongOfUser.mock.t.Fatalf("PlaylistRepositoryMock.GetFirstSongOfUser mock is already set by Set")
	}

	if mmGetFirstSongOfUser.defaultExpectation == nil {
		mmGetFirstSongOfUser.defaultExpectation = &PlaylistRepositoryMockGetFirstSongOfUserExpectation{}
	}

	if mmGetFirstSongOfUser.defaultExpectation.paramPtrs != nil {
		mmGetFirstSongOfUser.mock.t.Fatalf("PlaylistRepositoryMock.GetFirstSongOfUser mock is already set by ExpectParams functions")
	}

	mmGetFirstSongOfUser.defaultExpectation.params = &PlaylistRepositoryMockGetFirstSongOfUserParams{ctx, login}
	mmGetFirstSongOfUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetFirstSongOfUser.expectations {
		if minimock.Equal(e.params, mmGetFirstSongOfUser.defaultExpectation.params) {
			mmGetFirstSongOfUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFirstSongOfUser.defaultExpectation.params)
		}
	}

	return mmGetFirstSongOfUser
}

// ExpectCtxParam1 sets up expected param ctx for PlaylistRepository.GetFirstSongOfUser
func (mmGetFirstSongOfUser *mPlaylistRepositoryMockGetFirstSongOfUser) ExpectCtxParam1(ctx context.Context) *mPlaylistRepositoryMockGetFirstSongOfUser {
	if mmGetFirstSongOfUser.mock.funcGetFirstSongOfUser != nil {
		mmGetFirstSongOfUser.mock.t.Fatalf("PlaylistRepositoryMock.GetFirstSongOfUser mock is already set by Set")
	}

	if mmGetFirstSongOfUser.defaultExpectation == nil {
		mmGetFirstSongOfUser.defaultExpectation = &PlaylistRepositoryMockGetFirstSongOfUserExpectation{}
	}

	if mmGetFirstSongOfUser.defaultExpectation.params != nil {
		mmGetFirstSongOfUser.mock.t.Fatalf("PlaylistRepositoryMock.GetFirstSongOfUser mock is already set by Expect")
	}

	if mmGetFirstSongOfUser.defaultExpectation.paramPtrs == nil {
		mmGetFirstSongOfUser.defaultExpectation.paramPtrs = &PlaylistRepositoryMockGetFirstSongOfUserParamPtrs{}
	}
	mmGetFirstSongOfUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetFirstSongOfUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetFirstSongOfUser
}

// ExpectLoginParam2 sets up expected param login for PlaylistRepository.GetFirstSongOfUser
func (mmGetFirstSongOfUser *mPlaylistRepositoryMockGetFirstSongOfUser) ExpectLoginParam2(login string) *mPlaylistRepositoryMockGetFirstSongOfUser {
	if mmGetFirstSongOfUser.mock.funcGetFirstSongOfUser != nil {
		mmGetFirstSongOfUser.mock.t.Fatalf("PlaylistRepositoryMock.GetFirstSongOfUser mock is already set by Set")
	}

	if mmGetFirstSongOfUser.defaultExpectation == nil {
		mmGetFirstSongOfUser.defaultExpectation = &PlaylistRepositoryMockGetFirstSongOfUserExpectation{}
	}

	if mmGetFirstSongOfUser.defaultExpectation.params != nil {
		mmGetFirstSongOfUser.mock.t.Fatalf("PlaylistRepositoryMock.GetFirstSongOfUser mock is already set by Expect")
	}

	if mmGetFirstSongOfUser.defaultExpectation.paramPtrs == nil {
		mmGetFirstSongOfUser.defaultExpectation.paramPtrs = &PlaylistRepositoryMockGetFirstSongOfUserParamPtrs{}
	}
	mmGetFirstSongOfUser.defaultExpectation.paramPtrs.login = &login
	mmGetFirstSongOfUser.defaultExpectation.expectationOrigins.originLogin = minimock.CallerInfo(1)

	return mmGetFirstSongOfUser
}

// Inspect accepts an inspector function that has same arguments as the PlaylistRepository.GetFirstSongOfUser
func (mmGetFirstSongOfUser *mPlaylistRepositoryMockGetFirstSongOfUser) Inspect(f func(ctx context.Context, login string)) *mPlaylistRepositoryMockGetFirstSongOfUser {
	if mmGetFirstSongOfUser.mock.inspectFuncGetFirstSongOfUser != nil {
		mmGetFirstSongOfUser.mock.t.Fatalf("Inspect function is already set for PlaylistRepositoryMock.GetFirstSongOfUser")
	}

	mmGetFirstSongOfUser.mock.inspectFuncGetFirstSongOfUser = f

	return mmGetFirstSongOfUser
}

// Return sets up results that will be returned by PlaylistRepository.GetFirstSongOfUser
func (mmGetFirstSongOfUser *mPlaylistRepositoryMockGetFirstSongOfUser) Return(s1 model.Song, err error) *PlaylistRepositoryMock {
	if mmGetFirstSongOfUser.mock.funcGetFirstSongOfUser != nil {
		mmGetFirstSongOfUser.mock.t.Fatalf("PlaylistRepositoryMock.GetFirstSongOfUser mock is already set by Set")
	}

	if mmGetFirstSongOfUser.defaultExpectation == nil {
		mmGetFirstSongOfUser.defaultExpectation = &PlaylistRepositoryMockGetFirstSongOfUserExpectation{mock: mmGetFirstSongOfUser.mock}
	}
	mmGetFirstSongOfUser.defaultExpectation.results = &PlaylistRepositoryMockGetFirstSongOfUserResults{s1, err}
	mmGetFirstSongOfUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetFirstSongOfUser.mock
}

// Set uses given function f to mock the PlaylistRepository.GetFirstSongOfUser method
func (mmGetFirstSongOfUser *mPlaylistRepositoryMockGetFirstSongOfUser) Set(f func(ctx context.Context, login string) (s1 model.Song, err error)) *PlaylistRepositoryMock {
	if mmGetFirstSongOfUser.defaultExpectation != nil {
		mmGetFirstSongOfUser.mock.t.Fatalf("Default expectation is already set for the PlaylistRepository.GetFirstSongOfUser method")
	}

	if len(mmGetFirstSongOfUser.expectations) > 0 {
		mmGetFirstSongOfUser.mock.t.Fatalf("Some expectations are already set for the PlaylistRepository.GetFirstSongOfUser method")
	}

	mmGetFirstSongOfUser.mock.funcGetFirstSongOfUser = f
	mmGetFirstSongOfUser.mock.funcGetFirstSongOfUserOrigin = minimock.CallerInfo(1)
	return mmGetFirstSongOfUser.mock
}

// When sets expectation for the PlaylistRepository.GetFirstSongOfUser which will trigger the result defined by the following
// Then helper
func (mmGetFirstSongOfUser *mPlaylistRepositoryMockGetFirstSongOfUser) When(ctx context.Context, login string) *PlaylistRepositoryMockGetFirstSongOfUserExpectation {
	if mmGetFirstSongOfUser.mock.funcGetFirstSongOfUser != nil {
		mmGetFirstSongOfUser.mock.t.Fatalf("PlaylistRepositoryMock.GetFirstSongOfUser mock is already set by Set")
	}

	expectation := &PlaylistRepositoryMockGetFirstSongOfUserExpectation{
		mock:               mmGetFirstSongOfUser.mock,
		params:             &PlaylistRepositoryMockGetFirstSongOfUserParams{ctx, login},
		expectationOrigins: PlaylistRepositoryMockGetFirstSongOfUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetFirstSongOfUser.expectations = append(mmGetFirstSongOfUser.expectations, expectation)
	return expectation
}

// Then sets up PlaylistRepository.GetFirstSongOfUser return parameters for the expectation previously defined by the When method
func (e *PlaylistRepositoryMockGetFirstSongOfUserExpectation) Then(s1 model.Song, err error) *PlaylistRepositoryMock {
	e.results = &PlaylistRepositoryMockGetFirstSongOfUserResults{s1, err}
	return e.mock
}

// Times sets number of times PlaylistRepository.GetFirstSongOfUser should be invoked
func (mmGetFirstSongOfUser *mPlaylistRepositoryMockGetFirstSongOfUser) Times(n uint64) *mPlaylistRepositoryMockGetFirstSongOfUser {
	if n == 0 {
		mmGetFirstSongOfUser.mock.t.Fatalf("Times of PlaylistRepositoryMock.GetFirstSongOfUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetFirstSongOfUser.expectedInvocations, n)
	mmGetFirstSongOfUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetFirstSongOfUser
}

func (mmGetFirstSongOfUser *mPlaylistRepositoryMockGetFirstSongOfUser) invocationsDone() bool {
	if len(mmGetFirstSongOfUser.expectations) == 0 && mmGetFirstSongOfUser.defaultExpectation == nil && mmGetFirstSongOfUser.mock.funcGetFirstSongOfUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetFirstSongOfUser.mock.afterGetFirstSongOfUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetFirstSongOfUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetFirstSongOfUser implements mm_playlist.PlaylistRepository
func (mmGetFirstSongOfUser *PlaylistRepositoryMock) GetFirstSongOfUser(ctx context.Context, login string) (s1 model.Song, err error) {
	mm_atomic.AddUint64(&mmGetFirstSongOfUser.beforeGetFirstSongOfUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFirstSongOfUser.afterGetFirstSongOfUserCounter, 1)

	mmGetFirstSongOfUser.t.Helper()

	if mmGetFirstSongOfUser.inspectFuncGetFirstSongOfUser != nil {
		mmGetFirstSongOfUser.inspectFuncGetFirstSongOfUser(ctx, login)
	}

	mm_params := PlaylistRepositoryMockGetFirstSongOfUserParams{ctx, login}

	// Record call args
	mmGetFirstSongOfUser.GetFirstSongOfUserMock.mutex.Lock()
	mmGetFirstSongOfUser.GetFirstSongOfUserMock.callArgs = append(mmGetFirstSongOfUser.GetFirstSongOfUserMock.callArgs, &mm_params)
	mmGetFirstSongOfUser.GetFirstSongOfUserMock.mutex.Unlock()

	for _, e := range mmGetFirstSongOfUser.GetFirstSongOfUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetFirstSongOfUser.GetFirstSongOfUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFirstSongOfUser.GetFirstSongOfUserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFirstSongOfUser.GetFirstSongOfUserMock.defaultExpectation.params
		mm_want_ptrs := mmGetFirstSongOfUser.GetFirstSongOfUserMock.defaultExpectation.paramPtrs

		mm_got := PlaylistRepositoryMockGetFirstSongOfUserParams{ctx, login}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetFirstSongOfUser.t.Errorf("PlaylistRepositoryMock.GetFirstSongOfUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFirstSongOfUser.GetFirstSongOfUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.login != nil && !minimock.Equal(*mm_want_ptrs.login, mm_got.login) {
				mmGetFirstSongOfUser.t.Errorf("PlaylistRepositoryMock.GetFirstSongOfUser got unexpected parameter login, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetFirstSongOfUser.GetFirstSongOfUserMock.defaultExpectation.expectationOrigins.originLogin, *mm_want_ptrs.login, mm_got.login, minimock.Diff(*mm_want_ptrs.login, mm_got.login))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFirstSongOfUser.t.Errorf("PlaylistRepositoryMock.GetFirstSongOfUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetFirstSongOfUser.GetFirstSongOfUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFirstSongOfUser.GetFirstSongOfUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFirstSongOfUser.t.Fatal("No results are set for the PlaylistRepositoryMock.GetFirstSongOfUser")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetFirstSongOfUser.funcGetFirstSongOfUser != nil {
		return mmGetFirstSongOfUser.funcGetFirstSongOfUser(ctx, login)
	}
	mmGetFirstSongOfUser.t.Fatalf("Unexpected call to PlaylistRepositoryMock.GetFirstSongOfUser. %v %v", ctx, login)
	return
}

// GetFirstSongOfUserAfterCounter returns a count of finished PlaylistRepositoryMock.GetFirstSongOfUser invocations
func (mmGetFirstSongOfUser *PlaylistRepositoryMock) GetFirstSongOfUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFirstSongOfUser.afterGetFirstSongOfUserCounter)
}

// GetFirstSongOfUserBeforeCounter returns a count of PlaylistRepositoryMock.GetFirstSongOfUser invocations
func (mmGetFirstSongOfUser *PlaylistRepositoryMock) GetFirstSongOfUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFirstSongOfUser.beforeGetFirstSongOfUserCounter)
}

// Calls returns a list of arguments used in each call to PlaylistRepositoryMock.GetFirstSongOfUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFirstSongOfUser *mPlaylistRepositoryMockGetFirstSongOfUser) Calls() []*PlaylistRepositoryMockGetFirstSongOfUserParams {
	mmGetFirstSongOfUser.mutex.RLock()

	argCopy := make([]*PlaylistRepositoryMockGetFirstSongOfUserParams, len(mmGetFirstSongOfUser.callArgs))
	copy(argCopy, mmGetFirstSongOfUser.callArgs)

	mmGetFirstSongOfUser.mutex.RUnlock()

	return argCopy
}

// MinimockGetFirstSongOfUserDone returns true if the count of the GetFirstSongOfUser invocations corresponds
// the number of defined expectations
func (m *PlaylistRepositoryMock) MinimockGetFirstSongOfUserDone() bool {
	if m.GetFirstSongOfUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetFirstSongOfUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetFirstSongOfUserMock.invocationsDone()
}

// MinimockGetFirstSongOfUserInspect logs each unmet expectation
func (m *PlaylistRepositoryMock) MinimockGetFirstSongOfUserInspect() {
	for _, e := range m.GetFirstSongOfUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PlaylistRepositoryMock.GetFirstSongOfUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetFirstSongOfUserCounter := mm_atomic.LoadUint64(&m.afterGetFirstSongOfUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetFirstSongOfUserMock.defaultExpectation != nil && afterGetFirstSongOfUserCounter < 1 {
		if m.GetFirstSongOfUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PlaylistRepositoryMock.GetFirstSongOfUser at\n%s", m.GetFirstSongOfUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PlaylistRepositoryMock.GetFirstSongOfUser at\n%s with params: %#v", m.GetFirstSongOfUserMock.defaultExpectation.expectationOrigins.origin, *m.GetFirstSongOfUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFirstSongOfUser != nil && afterGetFirstSongOfUserCounter < 1 {
		m.t.Errorf("Expected call to PlaylistRepositoryMock.GetFirstSongOfUser at\n%s", m.funcGetFirstSongOfUserOrigin)
	}

	if !m.GetFirstSongOfUserMock.invocationsDone() && afterGetFirstSongOfUserCounter > 0 {
		m.t.Errorf("Expected %d calls to PlaylistRepositoryMock.GetFirstSongOfUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetFirstSongOfUserMock.expectedInvocations), m.GetFirstSongOfUserMock.expectedInvocationsOrigin, afterGetFirstSongOfUserCounter)
	}
}

type mPlaylistRepositoryMockGetNextSongOfUser struct {
	optional           bool
	mock               *PlaylistRepositoryMock
	defaultExpectation *PlaylistRepositoryMockGetNextSongOfUserExpectation
	expectations       []*PlaylistRepositoryMockGetNextSongOfUserExpectation

	callArgs []*PlaylistRepositoryMockGetNextSongOfUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PlaylistRepositoryMockGetNextSongOfUserExpectation specifies expectation struct of the PlaylistRepository.GetNextSongOfUser
type PlaylistRepositoryMockGetNextSongOfUserExpectation struct {
	mock               *PlaylistRepositoryMock
	params             *PlaylistRepositoryMockGetNextSongOfUserParams
	paramPtrs          *PlaylistRepositoryMockGetNextSongOfUserParamPtrs
	expectationOrigins PlaylistRepositoryMockGetNextSongOfUserExpectationOrigins
	results            *PlaylistRepositoryMockGetNextSongOfUserResults
	returnOrigin       string
	Counter            uint64
}

// PlaylistRepositoryMockGetNextSongOfUserParams contains parameters of the PlaylistRepository.GetNextSongOfUser
type PlaylistRepositoryMockGetNextSongOfUserParams struct {
	ctx    context.Context
	login  string
	curID  int64
	nextID int64
}

// PlaylistRepositoryMockGetNextSongOfUserParamPtrs contains pointers to parameters of the PlaylistRepository.GetNextSongOfUser
type PlaylistRepositoryMockGetNextSongOfUserParamPtrs struct {
	ctx    *context.Context
	login  *string
	curID  *int64
	nextID *int64
}

// PlaylistRepositoryMockGetNextSongOfUserResults contains results of the PlaylistRepository.GetNextSongOfUser
type PlaylistRepositoryMockGetNextSongOfUserResults struct {
	s1  model.Song
	err error
}

// PlaylistRepositoryMockGetNextSongOfUserOrigins contains origins of expectations of the PlaylistRepository.GetNextSongOfUser
type PlaylistRepositoryMockGetNextSongOfUserExpectationOrigins struct {
	origin       string
	originCtx    string
	originLogin  string
	originCurID  string
	originNextID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetNextSongOfUser *mPlaylistRepositoryMockGetNextSongOfUser) Optional() *mPlaylistRepositoryMockGetNextSongOfUser {
	mmGetNextSongOfUser.optional = true
	return mmGetNextSongOfUser
}

// Expect sets up expected params for PlaylistRepository.GetNextSongOfUser
func (mmGetNextSongOfUser *mPlaylistRepositoryMockGetNextSongOfUser) Expect(ctx context.Context, login string, curID int64, nextID int64) *mPlaylistRepositoryMockGetNextSongOfUser {
	if mmGetNextSongOfUser.mock.funcGetNextSongOfUser != nil {
		mmGetNextSongOfUser.mock.t.Fatalf("PlaylistRepositoryMock.GetNextSongOfUser mock is already set by Set")
	}

	if mmGetNextSongOfUser.defaultExpectation == nil {
		mmGetNextSongOfUser.defaultExpectation = &PlaylistRepositoryMockGetNextSongOfUserExpectation{}
	}

	if mmGetNextSongOfUser.defaultExpectation.paramPtrs != nil {
		mmGetNextSongOfUser.mock.t.Fatalf("PlaylistRepositoryMock.GetNextSongOfUser mock is already set by ExpectParams functions")
	}

	mmGetNextSongOfUser.defaultExpectation.params = &PlaylistRepositoryMockGetNextSongOfUserParams{ctx, login, curID, nextID}
	mmGetNextSongOfUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetNextSongOfUser.expectations {
		if minimock.Equal(e.params, mmGetNextSongOfUser.defaultExpectation.params) {
			mmGetNextSongOfUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetNextSongOfUser.defaultExpectation.params)
		}
	}

	return mmGetNextSongOfUser
}

// ExpectCtxParam1 sets up expected param ctx for PlaylistRepository.GetNextSongOfUser
func (mmGetNextSongOfUser *mPlaylistRepositoryMockGetNextSongOfUser) ExpectCtxParam1(ctx context.Context) *mPlaylistRepositoryMockGetNextSongOfUser {
	if mmGetNextSongOfUser.mock.funcGetNextSongOfUser != nil {
		mmGetNextSongOfUser.mock.t.Fatalf("PlaylistRepositoryMock.GetNextSongOfUser mock is already set by Set")
	}

	if mmGetNextSongOfUser.defaultExpectation == nil {
		mmGetNextSongOfUser.defaultExpectation = &PlaylistRepositoryMockGetNextSongOfUserExpectation{}
	}

	if mmGetNextSongOfUser.defaultExpectation.params != nil {
		mmGetNextSongOfUser.mock.t.Fatalf("PlaylistRepositoryMock.GetNextSongOfUser mock is already set by Expect")
	}

	if mmGetNextSongOfUser.defaultExpectation.paramPtrs == nil {
		mmGetNextSongOfUser.defaultExpectation.paramPtrs = &PlaylistRepositoryMockGetNextSongOfUserParamPtrs{}
	}
	mmGetNextSongOfUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetNextSongOfUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetNextSongOfUser
}

// ExpectLoginParam2 sets up expected param login for PlaylistRepository.GetNextSongOfUser
func (mmGetNextSongOfUser *mPlaylistRepositoryMockGetNextSongOfUser) ExpectLoginParam2(login string) *mPlaylistRepositoryMockGetNextSongOfUser {
	if mmGetNextSongOfUser.mock.funcGetNextSongOfUser != nil {
		mmGetNextSongOfUser.mock.t.Fatalf("PlaylistRepositoryMock.GetNextSongOfUser mock is already set by Set")
	}

	if mmGetNextSongOfUser.defaultExpectation == nil {
		mmGetNextSongOfUser.defaultExpectation = &PlaylistRepositoryMockGetNextSongOfUserExpectation{}
	}

	if mmGetNextSongOfUser.defaultExpectation.params != nil {
		mmGetNextSongOfUser.mock.t.Fatalf("PlaylistRepositoryMock.GetNextSongOfUser mock is already set by Expect")
	}

	if mmGetNextSongOfUser.defaultExpectation.paramPtrs == nil {
		mmGetNextSongOfUser.defaultExpectation.paramPtrs = &PlaylistRepositoryMockGetNextSongOfUserParamPtrs{}
	}
	mmGetNextSongOfUser.defaultExpectation.paramPtrs.login = &login
	mmGetNextSongOfUser.defaultExpectation.expectationOrigins.originLogin = minimock.CallerInfo(1)

	return mmGetNextSongOfUser
}

// ExpectCurIDParam3 sets up expected param curID for PlaylistRepository.GetNextSongOfUser
func (mmGetNextSongOfUser *mPlaylistRepositoryMockGetNextSongOfUser) ExpectCurIDParam3(curID int64) *mPlaylistRepositoryMockGetNextSongOfUser {
	if mmGetNextSongOfUser.mock.funcGetNextSongOfUser != nil {
		mmGetNextSongOfUser.mock.t.Fatalf("PlaylistRepositoryMock.GetNextSongOfUser mock is already set by Set")
	}

	if mmGetNextSongOfUser.defaultExpectation == nil {
		mmGetNextSongOfUser.defaultExpectation = &PlaylistRepositoryMockGetNextSongOfUserExpectation{}
	}

	if mmGetNextSongOfUser.defaultExpectation.params != nil {
		mmGetNextSongOfUser.mock.t.Fatalf("PlaylistRepositoryMock.GetNextSongOfUser mock is already set by Expect")
	}

	if mmGetNextSongOfUser.defaultExpectation.paramPtrs == nil {
		mmGetNextSongOfUser.defaultExpectation.paramPtrs = &PlaylistRepositoryMockGetNextSongOfUserParamPtrs{}
	}
	mmGetNextSongOfUser.defaultExpectation.paramPtrs.curID = &curID
	mmGetNextSongOfUser.defaultExpectation.expectationOrigins.originCurID = minimock.CallerInfo(1)

	return mmGetNextSongOfUser
}

// ExpectNextIDParam4 sets up expected param nextID for PlaylistRepository.GetNextSongOfUser
func (mmGetNextSongOfUser *mPlaylistRepositoryMockGetNextSongOfUser) ExpectNextIDParam4(nextID int64) *mPlaylistRepositoryMockGetNextSongOfUser {
	if mmGetNextSongOfUser.mock.funcGetNextSongOfUser != nil {
		mmGetNextSongOfUser.mock.t.Fatalf("PlaylistRepositoryMock.GetNextSongOfUser mock is already set by Set")
	}

	if mmGetNextSongOfUser.defaultExpectation == nil {
		mmGetNextSongOfUser.defaultExpectation = &PlaylistRepositoryMockGetNextSongOfUserExpectation{}
	}

	if mmGetNextSongOfUser.defaultExpectation.params != nil {
		mmGetNextSongOfUser.mock.t.Fatalf("PlaylistRepositoryMock.GetNextSongOfUser mock is already set by Expect")
	}

	if mmGetNextSongOfUser.defaultExpectation.paramPtrs == nil {
		mmGetNextSongOfUser.defaultExpectation.paramPtrs = &PlaylistRepositoryMockGetNextSongOfUserParamPtrs{}
	}
	mmGetNextSongOfUser.defaultExpectation.paramPtrs.nextID = &nextID
	mmGetNextSongOfUser.defaultExpectation.expectationOrigins.originNextID = minimock.CallerInfo(1)

	return mmGetNextSongOfUser
}

// Inspect accepts an inspector function that has same arguments as the PlaylistRepository.GetNextSongOfUser
func (mmGetNextSongOfUser *mPlaylistRepositoryMockGetNextSongOfUser) Inspect(f func(ctx context.Context, login string, curID int64, nextID int64)) *mPlaylistRepositoryMockGetNextSongOfUser {
	if mmGetNextSongOfUser.mock.inspectFuncGetNextSongOfUser != nil {
		mmGetNextSongOfUser.mock.t.Fatalf("Inspect function is already set for PlaylistRepositoryMock.GetNextSongOfUser")
	}

	mmGetNextSongOfUser.mock.inspectFuncGetNextSongOfUser = f

	return mmGetNextSongOfUser
}

// Return sets up results that will be returned by PlaylistRepository.GetNextSongOfUser
func (mmGetNextSongOfUser *mPlaylistRepositoryMockGetNextSongOfUser) Return(s1 model.Song, err error) *PlaylistRepositoryMock {
	if mmGetNextSongOfUser.mock.funcGetNextSongOfUser != nil {
		mmGetNextSongOfUser.mock.t.Fatalf("PlaylistRepositoryMock.GetNextSongOfUser mock is already set by Set")
	}

	if mmGetNextSongOfUser.defaultExpectation == nil {
		mmGetNextSongOfUser.defaultExpectation = &PlaylistRepositoryMockGetNextSongOfUserExpectation{mock: mmGetNextSongOfUser.mock}
	}
	mmGetNextSongOfUser.defaultExpectation.results = &PlaylistRepositoryMockGetNextSongOfUserResults{s1, err}
	mmGetNextSongOfUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetNextSongOfUser.mock
}

// Set uses given function f to mock the PlaylistRepository.GetNextSongOfUser method
func (mmGetNextSongOfUser *mPlaylistRepositoryMockGetNextSongOfUser) Set(f func(ctx context.Context, login string, curID int64, nextID int64) (s1 model.Song, err error)) *PlaylistRepositoryMock {
	if mmGetNextSongOfUser.defaultExpectation != nil {
		mmGetNextSongOfUser.mock.t.Fatalf("Default expectation is already set for the PlaylistRepository.GetNextSongOfUser method")
	}

	if len(mmGetNextSongOfUser.expectations) > 0 {
		mmGetNextSongOfUser.mock.t.Fatalf("Some expectations are already set for the PlaylistRepository.GetNextSongOfUser method")
	}

	mmGetNextSongOfUser.mock.funcGetNextSongOfUser = f
	mmGetNextSongOfUser.mock.funcGetNextSongOfUserOrigin = minimock.CallerInfo(1)
	return mmGetNextSongOfUser.mock
}

// When sets expectation for the PlaylistRepository.GetNextSongOfUser which will trigger the result defined by the following
// Then helper
func (mmGetNextSongOfUser *mPlaylistRepositoryMockGetNextSongOfUser) When(ctx context.Context, login string, curID int64, nextID int64) *PlaylistRepositoryMockGetNextSongOfUserExpectation {
	if mmGetNextSongOfUser.mock.funcGetNextSongOfUser != nil {
		mmGetNextSongOfUser.mock.t.Fatalf("PlaylistRepositoryMock.GetNextSongOfUser mock is already set by Set")
	}

	expectation := &PlaylistRepositoryMockGetNextSongOfUserExpectation{
		mock:               mmGetNextSongOfUser.mock,
		params:             &PlaylistRepositoryMockGetNextSongOfUserParams{ctx, login, curID, nextID},
		expectationOrigins: PlaylistRepositoryMockGetNextSongOfUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetNextSongOfUser.expectations = append(mmGetNextSongOfUser.expectations, expectation)
	return expectation
}

// Then sets up PlaylistRepository.GetNextSongOfUser return parameters for the expectation previously defined by the When method
func (e *PlaylistRepositoryMockGetNextSongOfUserExpectation) Then(s1 model.Song, err error) *PlaylistRepositoryMock {
	e.results = &PlaylistRepositoryMockGetNextSongOfUserResults{s1, err}
	return e.mock
}

// Times sets number of times PlaylistRepository.GetNextSongOfUser should be invoked
func (mmGetNextSongOfUser *mPlaylistRepositoryMockGetNextSongOfUser) Times(n uint64) *mPlaylistRepositoryMockGetNextSongOfUser {
	if n == 0 {
		mmGetNextSongOfUser.mock.t.Fatalf("Times of PlaylistRepositoryMock.GetNextSongOfUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetNextSongOfUser.expectedInvocations, n)
	mmGetNextSongOfUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetNextSongOfUser
}

func (mmGetNextSongOfUser *mPlaylistRepositoryMockGetNextSongOfUser) invocationsDone() bool {
	if len(mmGetNextSongOfUser.expectations) == 0 && mmGetNextSongOfUser.defaultExpectation == nil && mmGetNextSongOfUser.mock.funcGetNextSongOfUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetNextSongOfUser.mock.afterGetNextSongOfUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetNextSongOfUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetNextSongOfUser implements mm_playlist.PlaylistRepository
func (mmGetNextSongOfUser *PlaylistRepositoryMock) GetNextSongOfUser(ctx context.Context, login string, curID int64, nextID int64) (s1 model.Song, err error) {
	mm_atomic.AddUint64(&mmGetNextSongOfUser.beforeGetNextSongOfUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNextSongOfUser.afterGetNextSongOfUserCounter, 1)

	mmGetNextSongOfUser.t.Helper()

	if mmGetNextSongOfUser.inspectFuncGetNextSongOfUser != nil {
		mmGetNextSongOfUser.inspectFuncGetNextSongOfUser(ctx, login, curID, nextID)
	}

	mm_params := PlaylistRepositoryMockGetNextSongOfUserParams{ctx, login, curID, nextID}

	// Record call args
	mmGetNextSongOfUser.GetNextSongOfUserMock.mutex.Lock()
	mmGetNextSongOfUser.GetNextSongOfUserMock.callArgs = append(mmGetNextSongOfUser.GetNextSongOfUserMock.callArgs, &mm_params)
	mmGetNextSongOfUser.GetNextSongOfUserMock.mutex.Unlock()

	for _, e := range mmGetNextSongOfUser.GetNextSongOfUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetNextSongOfUser.GetNextSongOfUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNextSongOfUser.GetNextSongOfUserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetNextSongOfUser.GetNextSongOfUserMock.defaultExpectation.params
		mm_want_ptrs := mmGetNextSongOfUser.GetNextSongOfUserMock.defaultExpectation.paramPtrs

		mm_got := PlaylistRepositoryMockGetNextSongOfUserParams{ctx, login, curID, nextID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetNextSongOfUser.t.Errorf("PlaylistRepositoryMock.GetNextSongOfUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNextSongOfUser.GetNextSongOfUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.login != nil && !minimock.Equal(*mm_want_ptrs.login, mm_got.login) {
				mmGetNextSongOfUser.t.Errorf("PlaylistRepositoryMock.GetNextSongOfUser got unexpected parameter login, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNextSongOfUser.GetNextSongOfUserMock.defaultExpectation.expectationOrigins.originLogin, *mm_want_ptrs.login, mm_got.login, minimock.Diff(*mm_want_ptrs.login, mm_got.login))
			}

			if mm_want_ptrs.curID != nil && !minimock.Equal(*mm_want_ptrs.curID, mm_got.curID) {
				mmGetNextSongOfUser.t.Errorf("PlaylistRepositoryMock.GetNextSongOfUser got unexpected parameter curID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNextSongOfUser.GetNextSongOfUserMock.defaultExpectation.expectationOrigins.originCurID, *mm_want_ptrs.curID, mm_got.curID, minimock.Diff(*mm_want_ptrs.curID, mm_got.curID))
			}

			if mm_want_ptrs.nextID != nil && !minimock.Equal(*mm_want_ptrs.nextID, mm_got.nextID) {
				mmGetNextSongOfUser.t.Errorf("PlaylistRepositoryMock.GetNextSongOfUser got unexpected parameter nextID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNextSongOfUser.GetNextSongOfUserMock.defaultExpectation.expectationOrigins.originNextID, *mm_want_ptrs.nextID, mm_got.nextID, minimock.Diff(*mm_want_ptrs.nextID, mm_got.nextID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetNextSongOfUser.t.Errorf("PlaylistRepositoryMock.GetNextSongOfUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetNextSongOfUser.GetNextSongOfUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetNextSongOfUser.GetNextSongOfUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetNextSongOfUser.t.Fatal("No results are set for the PlaylistRepositoryMock.GetNextSongOfUser")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetNextSongOfUser.funcGetNextSongOfUser != nil {
		return mmGetNextSongOfUser.funcGetNextSongOfUser(ctx, login, curID, nextID)
	}
	mmGetNextSongOfUser.t.Fatalf("Unexpected call to PlaylistRepositoryMock.GetNextSongOfUser. %v %v %v %v", ctx, login, curID, nextID)
	return
}

// GetNextSongOfUserAfterCounter returns a count of finished PlaylistRepositoryMock.GetNextSongOfUser invocations
func (mmGetNextSongOfUser *PlaylistRepositoryMock) GetNextSongOfUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNextSongOfUser.afterGetNextSongOfUserCounter)
}

// GetNextSongOfUserBeforeCounter returns a count of PlaylistRepositoryMock.GetNextSongOfUser invocations
func (mmGetNextSongOfUser *PlaylistRepositoryMock) GetNextSongOfUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNextSongOfUser.beforeGetNextSongOfUserCounter)
}

// Calls returns a list of arguments used in each call to PlaylistRepositoryMock.GetNextSongOfUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetNextSongOfUser *mPlaylistRepositoryMockGetNextSongOfUser) Calls() []*PlaylistRepositoryMockGetNextSongOfUserParams {
	mmGetNextSongOfUser.mutex.RLock()

	argCopy := make([]*PlaylistRepositoryMockGetNextSongOfUserParams, len(mmGetNextSongOfUser.callArgs))
	copy(argCopy, mmGetNextSongOfUser.callArgs)

	mmGetNextSongOfUser.mutex.RUnlock()

	return argCopy
}

// MinimockGetNextSongOfUserDone returns true if the count of the GetNextSongOfUser invocations corresponds
// the number of defined expectations
func (m *PlaylistRepositoryMock) MinimockGetNextSongOfUserDone() bool {
	if m.GetNextSongOfUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetNextSongOfUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetNextSongOfUserMock.invocationsDone()
}

// MinimockGetNextSongOfUserInspect logs each unmet expectation
func (m *PlaylistRepositoryMock) MinimockGetNextSongOfUserInspect() {
	for _, e := range m.GetNextSongOfUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PlaylistRepositoryMock.GetNextSongOfUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetNextSongOfUserCounter := mm_atomic.LoadUint64(&m.afterGetNextSongOfUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetNextSongOfUserMock.defaultExpectation != nil && afterGetNextSongOfUserCounter < 1 {
		if m.GetNextSongOfUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PlaylistRepositoryMock.GetNextSongOfUser at\n%s", m.GetNextSongOfUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PlaylistRepositoryMock.GetNextSongOfUser at\n%s with params: %#v", m.GetNextSongOfUserMock.defaultExpectation.expectationOrigins.origin, *m.GetNextSongOfUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNextSongOfUser != nil && afterGetNextSongOfUserCounter < 1 {
		m.t.Errorf("Expected call to PlaylistRepositoryMock.GetNextSongOfUser at\n%s", m.funcGetNextSongOfUserOrigin)
	}

	if !m.GetNextSongOfUserMock.invocationsDone() && afterGetNextSongOfUserCounter > 0 {
		m.t.Errorf("Expected %d calls to PlaylistRepositoryMock.GetNextSongOfUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetNextSongOfUserMock.expectedInvocations), m.GetNextSongOfUserMock.expectedInvocationsOrigin, afterGetNextSongOfUserCounter)
	}
}

type mPlaylistRepositoryMockGetPrevSongOfUser struct {
	optional           bool
	mock               *PlaylistRepositoryMock
	defaultExpectation *PlaylistRepositoryMockGetPrevSongOfUserExpectation
	expectations       []*PlaylistRepositoryMockGetPrevSongOfUserExpectation

	callArgs []*PlaylistRepositoryMockGetPrevSongOfUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PlaylistRepositoryMockGetPrevSongOfUserExpectation specifies expectation struct of the PlaylistRepository.GetPrevSongOfUser
type PlaylistRepositoryMockGetPrevSongOfUserExpectation struct {
	mock               *PlaylistRepositoryMock
	params             *PlaylistRepositoryMockGetPrevSongOfUserParams
	paramPtrs          *PlaylistRepositoryMockGetPrevSongOfUserParamPtrs
	expectationOrigins PlaylistRepositoryMockGetPrevSongOfUserExpectationOrigins
	results            *PlaylistRepositoryMockGetPrevSongOfUserResults
	returnOrigin       string
	Counter            uint64
}

// PlaylistRepositoryMockGetPrevSongOfUserParams contains parameters of the PlaylistRepository.GetPrevSongOfUser
type PlaylistRepositoryMockGetPrevSongOfUserParams struct {
	ctx    context.Context
	login  string
	currID int64
	prevID int64
}

// PlaylistRepositoryMockGetPrevSongOfUserParamPtrs contains pointers to parameters of the PlaylistRepository.GetPrevSongOfUser
type PlaylistRepositoryMockGetPrevSongOfUserParamPtrs struct {
	ctx    *context.Context
	login  *string
	currID *int64
	prevID *int64
}

// PlaylistRepositoryMockGetPrevSongOfUserResults contains results of the PlaylistRepository.GetPrevSongOfUser
type PlaylistRepositoryMockGetPrevSongOfUserResults struct {
	s1  model.Song
	err error
}

// PlaylistRepositoryMockGetPrevSongOfUserOrigins contains origins of expectations of the PlaylistRepository.GetPrevSongOfUser
type PlaylistRepositoryMockGetPrevSongOfUserExpectationOrigins struct {
	origin       string
	originCtx    string
	originLogin  string
	originCurrID string
	originPrevID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPrevSongOfUser *mPlaylistRepositoryMockGetPrevSongOfUser) Optional() *mPlaylistRepositoryMockGetPrevSongOfUser {
	mmGetPrevSongOfUser.optional = true
	return mmGetPrevSongOfUser
}

// Expect sets up expected params for PlaylistRepository.GetPrevSongOfUser
func (mmGetPrevSongOfUser *mPlaylistRepositoryMockGetPrevSongOfUser) Expect(ctx context.Context, login string, currID int64, prevID int64) *mPlaylistRepositoryMockGetPrevSongOfUser {
	if mmGetPrevSongOfUser.mock.funcGetPrevSongOfUser != nil {
		mmGetPrevSongOfUser.mock.t.Fatalf("PlaylistRepositoryMock.GetPrevSongOfUser mock is already set by Set")
	}

	if mmGetPrevSongOfUser.defaultExpectation == nil {
		mmGetPrevSongOfUser.defaultExpectation = &PlaylistRepositoryMockGetPrevSongOfUserExpectation{}
	}

	if mmGetPrevSongOfUser.defaultExpectation.paramPtrs != nil {
		mmGetPrevSongOfUser.mock.t.Fatalf("PlaylistRepositoryMock.GetPrevSongOfUser mock is already set by ExpectParams functions")
	}

	mmGetPrevSongOfUser.defaultExpectation.params = &PlaylistRepositoryMockGetPrevSongOfUserParams{ctx, login, currID, prevID}
	mmGetPrevSongOfUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPrevSongOfUser.expectations {
		if minimock.Equal(e.params, mmGetPrevSongOfUser.defaultExpectation.params) {
			mmGetPrevSongOfUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPrevSongOfUser.defaultExpectation.params)
		}
	}

	return mmGetPrevSongOfUser
}

// ExpectCtxParam1 sets up expected param ctx for PlaylistRepository.GetPrevSongOfUser
func (mmGetPrevSongOfUser *mPlaylistRepositoryMockGetPrevSongOfUser) ExpectCtxParam1(ctx context.Context) *mPlaylistRepositoryMockGetPrevSongOfUser {
	if mmGetPrevSongOfUser.mock.funcGetPrevSongOfUser != nil {
		mmGetPrevSongOfUser.mock.t.Fatalf("PlaylistRepositoryMock.GetPrevSongOfUser mock is already set by Set")
	}

	if mmGetPrevSongOfUser.defaultExpectation == nil {
		mmGetPrevSongOfUser.defaultExpectation = &PlaylistRepositoryMockGetPrevSongOfUserExpectation{}
	}

	if mmGetPrevSongOfUser.defaultExpectation.params != nil {
		mmGetPrevSongOfUser.mock.t.Fatalf("PlaylistRepositoryMock.GetPrevSongOfUser mock is already set by Expect")
	}

	if mmGetPrevSongOfUser.defaultExpectation.paramPtrs == nil {
		mmGetPrevSongOfUser.defaultExpectation.paramPtrs = &PlaylistRepositoryMockGetPrevSongOfUserParamPtrs{}
	}
	mmGetPrevSongOfUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPrevSongOfUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPrevSongOfUser
}

// ExpectLoginParam2 sets up expected param login for PlaylistRepository.GetPrevSongOfUser
func (mmGetPrevSongOfUser *mPlaylistRepositoryMockGetPrevSongOfUser) ExpectLoginParam2(login string) *mPlaylistRepositoryMockGetPrevSongOfUser {
	if mmGetPrevSongOfUser.mock.funcGetPrevSongOfUser != nil {
		mmGetPrevSongOfUser.mock.t.Fatalf("PlaylistRepositoryMock.GetPrevSongOfUser mock is already set by Set")
	}

	if mmGetPrevSongOfUser.defaultExpectation == nil {
		mmGetPrevSongOfUser.defaultExpectation = &PlaylistRepositoryMockGetPrevSongOfUserExpectation{}
	}

	if mmGetPrevSongOfUser.defaultExpectation.params != nil {
		mmGetPrevSongOfUser.mock.t.Fatalf("PlaylistRepositoryMock.GetPrevSongOfUser mock is already set by Expect")
	}

	if mmGetPrevSongOfUser.defaultExpectation.paramPtrs == nil {
		mmGetPrevSongOfUser.defaultExpectation.paramPtrs = &PlaylistRepositoryMockGetPrevSongOfUserParamPtrs{}
	}
	mmGetPrevSongOfUser.defaultExpectation.paramPtrs.login = &login
	mmGetPrevSongOfUser.defaultExpectation.expectationOrigins.originLogin = minimock.CallerInfo(1)

	return mmGetPrevSongOfUser
}

// ExpectCurrIDParam3 sets up expected param currID for PlaylistRepository.GetPrevSongOfUser
func (mmGetPrevSongOfUser *mPlaylistRepositoryMockGetPrevSongOfUser) ExpectCurrIDParam3(currID int64) *mPlaylistRepositoryMockGetPrevSongOfUser {
	if mmGetPrevSongOfUser.mock.funcGetPrevSongOfUser != nil {
		mmGetPrevSongOfUser.mock.t.Fatalf("PlaylistRepositoryMock.GetPrevSongOfUser mock is already set by Set")
	}

	if mmGetPrevSongOfUser.defaultExpectation == nil {
		mmGetPrevSongOfUser.defaultExpectation = &PlaylistRepositoryMockGetPrevSongOfUserExpectation{}
	}

	if mmGetPrevSongOfUser.defaultExpectation.params != nil {
		mmGetPrevSongOfUser.mock.t.Fatalf("PlaylistRepositoryMock.GetPrevSongOfUser mock is already set by Expect")
	}

	if mmGetPrevSongOfUser.defaultExpectation.paramPtrs == nil {
		mmGetPrevSongOfUser.defaultExpectation.paramPtrs = &PlaylistRepositoryMockGetPrevSongOfUserParamPtrs{}
	}
	mmGetPrevSongOfUser.defaultExpectation.paramPtrs.currID = &currID
	mmGetPrevSongOfUser.defaultExpectation.expectationOrigins.originCurrID = minimock.CallerInfo(1)

	return mmGetPrevSongOfUser
}

// ExpectPrevIDParam4 sets up expected param prevID for PlaylistRepository.GetPrevSongOfUser
func (mmGetPrevSongOfUser *mPlaylistRepositoryMockGetPrevSongOfUser) ExpectPrevIDParam4(prevID int64) *mPlaylistRepositoryMockGetPrevSongOfUser {
	if mmGetPrevSongOfUser.mock.funcGetPrevSongOfUser != nil {
		mmGetPrevSongOfUser.mock.t.Fatalf("PlaylistRepositoryMock.GetPrevSongOfUser mock is already set by Set")
	}

	if mmGetPrevSongOfUser.defaultExpectation == nil {
		mmGetPrevSongOfUser.defaultExpectation = &PlaylistRepositoryMockGetPrevSongOfUserExpectation{}
	}

	if mmGetPrevSongOfUser.defaultExpectation.params != nil {
		mmGetPrevSongOfUser.mock.t.Fatalf("PlaylistRepositoryMock.GetPrevSongOfUser mock is already set by Expect")
	}

	if mmGetPrevSongOfUser.defaultExpectation.paramPtrs == nil {
		mmGetPrevSongOfUser.defaultExpectation.paramPtrs = &PlaylistRepositoryMockGetPrevSongOfUserParamPtrs{}
	}
	mmGetPrevSongOfUser.defaultExpectation.paramPtrs.prevID = &prevID
	mmGetPrevSongOfUser.defaultExpectation.expectationOrigins.originPrevID = minimock.CallerInfo(1)

	return mmGetPrevSongOfUser
}

// Inspect accepts an inspector function that has same arguments as the PlaylistRepository.GetPrevSongOfUser
func (mmGetPrevSongOfUser *mPlaylistRepositoryMockGetPrevSongOfUser) Inspect(f func(ctx context.Context, login string, currID int64, prevID int64)) *mPlaylistRepositoryMockGetPrevSongOfUser {
	if mmGetPrevSongOfUser.mock.inspectFuncGetPrevSongOfUser != nil {
		mmGetPrevSongOfUser.mock.t.Fatalf("Inspect function is already set for PlaylistRepositoryMock.GetPrevSongOfUser")
	}

	mmGetPrevSongOfUser.mock.inspectFuncGetPrevSongOfUser = f

	return mmGetPrevSongOfUser
}

// Return sets up results that will be returned by PlaylistRepository.GetPrevSongOfUser
func (mmGetPrevSongOfUser *mPlaylistRepositoryMockGetPrevSongOfUser) Return(s1 model.Song, err error) *PlaylistRepositoryMock {
	if mmGetPrevSongOfUser.mock.funcGetPrevSongOfUser != nil {
		mmGetPrevSongOfUser.mock.t.Fatalf("PlaylistRepositoryMock.GetPrevSongOfUser mock is already set by Set")
	}

	if mmGetPrevSongOfUser.defaultExpectation == nil {
		mmGetPrevSongOfUser.defaultExpectation = &PlaylistRepositoryMockGetPrevSongOfUserExpectation{mock: mmGetPrevSongOfUser.mock}
	}
	mmGetPrevSongOfUser.defaultExpectation.results = &PlaylistRepositoryMockGetPrevSongOfUserResults{s1, err}
	mmGetPrevSongOfUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPrevSongOfUser.mock
}

// Set uses given function f to mock the PlaylistRepository.GetPrevSongOfUser method
func (mmGetPrevSongOfUser *mPlaylistRepositoryMockGetPrevSongOfUser) Set(f func(ctx context.Context, login string, currID int64, prevID int64) (s1 model.Song, err error)) *PlaylistRepositoryMock {
	if mmGetPrevSongOfUser.defaultExpectation != nil {
		mmGetPrevSongOfUser.mock.t.Fatalf("Default expectation is already set for the PlaylistRepository.GetPrevSongOfUser method")
	}

	if len(mmGetPrevSongOfUser.expectations) > 0 {
		mmGetPrevSongOfUser.mock.t.Fatalf("Some expectations are already set for the PlaylistRepository.GetPrevSongOfUser method")
	}

	mmGetPrevSongOfUser.mock.funcGetPrevSongOfUser = f
	mmGetPrevSongOfUser.mock.funcGetPrevSongOfUserOrigin = minimock.CallerInfo(1)
	return mmGetPrevSongOfUser.mock
}

// When sets expectation for the PlaylistRepository.GetPrevSongOfUser which will trigger the result defined by the following
// Then helper
func (mmGetPrevSongOfUser *mPlaylistRepositoryMockGetPrevSongOfUser) When(ctx context.Context, login string, currID int64, prevID int64) *PlaylistRepositoryMockGetPrevSongOfUserExpectation {
	if mmGetPrevSongOfUser.mock.funcGetPrevSongOfUser != nil {
		mmGetPrevSongOfUser.mock.t.Fatalf("PlaylistRepositoryMock.GetPrevSongOfUser mock is already set by Set")
	}

	expectation := &PlaylistRepositoryMockGetPrevSongOfUserExpectation{
		mock:               mmGetPrevSongOfUser.mock,
		params:             &PlaylistRepositoryMockGetPrevSongOfUserParams{ctx, login, currID, prevID},
		expectationOrigins: PlaylistRepositoryMockGetPrevSongOfUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPrevSongOfUser.expectations = append(mmGetPrevSongOfUser.expectations, expectation)
	return expectation
}

// Then sets up PlaylistRepository.GetPrevSongOfUser return parameters for the expectation previously defined by the When method
func (e *PlaylistRepositoryMockGetPrevSongOfUserExpectation) Then(s1 model.Song, err error) *PlaylistRepositoryMock {
	e.results = &PlaylistRepositoryMockGetPrevSongOfUserResults{s1, err}
	return e.mock
}

// Times sets number of times PlaylistRepository.GetPrevSongOfUser should be invoked
func (mmGetPrevSongOfUser *mPlaylistRepositoryMockGetPrevSongOfUser) Times(n uint64) *mPlaylistRepositoryMockGetPrevSongOfUser {
	if n == 0 {
		mmGetPrevSongOfUser.mock.t.Fatalf("Times of PlaylistRepositoryMock.GetPrevSongOfUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPrevSongOfUser.expectedInvocations, n)
	mmGetPrevSongOfUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPrevSongOfUser
}

func (mmGetPrevSongOfUser *mPlaylistRepositoryMockGetPrevSongOfUser) invocationsDone() bool {
	if len(mmGetPrevSongOfUser.expectations) == 0 && mmGetPrevSongOfUser.defaultExpectation == nil && mmGetPrevSongOfUser.mock.funcGetPrevSongOfUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPrevSongOfUser.mock.afterGetPrevSongOfUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPrevSongOfUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPrevSongOfUser implements mm_playlist.PlaylistRepository
func (mmGetPrevSongOfUser *PlaylistRepositoryMock) GetPrevSongOfUser(ctx context.Context, login string, currID int64, prevID int64) (s1 model.Song, err error) {
	mm_atomic.AddUint64(&mmGetPrevSongOfUser.beforeGetPrevSongOfUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPrevSongOfUser.afterGetPrevSongOfUserCounter, 1)

	mmGetPrevSongOfUser.t.Helper()

	if mmGetPrevSongOfUser.inspectFuncGetPrevSongOfUser != nil {
		mmGetPrevSongOfUser.inspectFuncGetPrevSongOfUser(ctx, login, currID, prevID)
	}

	mm_params := PlaylistRepositoryMockGetPrevSongOfUserParams{ctx, login, currID, prevID}

	// Record call args
	mmGetPrevSongOfUser.GetPrevSongOfUserMock.mutex.Lock()
	mmGetPrevSongOfUser.GetPrevSongOfUserMock.callArgs = append(mmGetPrevSongOfUser.GetPrevSongOfUserMock.callArgs, &mm_params)
	mmGetPrevSongOfUser.GetPrevSongOfUserMock.mutex.Unlock()

	for _, e := range mmGetPrevSongOfUser.GetPrevSongOfUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetPrevSongOfUser.GetPrevSongOfUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPrevSongOfUser.GetPrevSongOfUserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPrevSongOfUser.GetPrevSongOfUserMock.defaultExpectation.params
		mm_want_ptrs := mmGetPrevSongOfUser.GetPrevSongOfUserMock.defaultExpectation.paramPtrs

		mm_got := PlaylistRepositoryMockGetPrevSongOfUserParams{ctx, login, currID, prevID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPrevSongOfUser.t.Errorf("PlaylistRepositoryMock.GetPrevSongOfUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPrevSongOfUser.GetPrevSongOfUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.login != nil && !minimock.Equal(*mm_want_ptrs.login, mm_got.login) {
				mmGetPrevSongOfUser.t.Errorf("PlaylistRepositoryMock.GetPrevSongOfUser got unexpected parameter login, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPrevSongOfUser.GetPrevSongOfUserMock.defaultExpectation.expectationOrigins.originLogin, *mm_want_ptrs.login, mm_got.login, minimock.Diff(*mm_want_ptrs.login, mm_got.login))
			}

			if mm_want_ptrs.currID != nil && !minimock.Equal(*mm_want_ptrs.currID, mm_got.currID) {
				mmGetPrevSongOfUser.t.Errorf("PlaylistRepositoryMock.GetPrevSongOfUser got unexpected parameter currID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPrevSongOfUser.GetPrevSongOfUserMock.defaultExpectation.expectationOrigins.originCurrID, *mm_want_ptrs.currID, mm_got.currID, minimock.Diff(*mm_want_ptrs.currID, mm_got.currID))
			}

			if mm_want_ptrs.prevID != nil && !minimock.Equal(*mm_want_ptrs.prevID, mm_got.prevID) {
				mmGetPrevSongOfUser.t.Errorf("PlaylistRepositoryMock.GetPrevSongOfUser got unexpected parameter prevID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPrevSongOfUser.GetPrevSongOfUserMock.defaultExpectation.expectationOrigins.originPrevID, *mm_want_ptrs.prevID, mm_got.prevID, minimock.Diff(*mm_want_ptrs.prevID, mm_got.prevID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPrevSongOfUser.t.Errorf("PlaylistRepositoryMock.GetPrevSongOfUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPrevSongOfUser.GetPrevSongOfUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPrevSongOfUser.GetPrevSongOfUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPrevSongOfUser.t.Fatal("No results are set for the PlaylistRepositoryMock.GetPrevSongOfUser")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetPrevSongOfUser.funcGetPrevSongOfUser != nil {
		return mmGetPrevSongOfUser.funcGetPrevSongOfUser(ctx, login, currID, prevID)
	}
	mmGetPrevSongOfUser.t.Fatalf("Unexpected call to PlaylistRepositoryMock.GetPrevSongOfUser. %v %v %v %v", ctx, login, currID, prevID)
	return
}

// GetPrevSongOfUserAfterCounter returns a count of finished PlaylistRepositoryMock.GetPrevSongOfUser invocations
func (mmGetPrevSongOfUser *PlaylistRepositoryMock) GetPrevSongOfUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPrevSongOfUser.afterGetPrevSongOfUserCounter)
}

// GetPrevSongOfUserBeforeCounter returns a count of PlaylistRepositoryMock.GetPrevSongOfUser invocations
func (mmGetPrevSongOfUser *PlaylistRepositoryMock) GetPrevSongOfUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPrevSongOfUser.beforeGetPrevSongOfUserCounter)
}

// Calls returns a list of arguments used in each call to PlaylistRepositoryMock.GetPrevSongOfUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPrevSongOfUser *mPlaylistRepositoryMockGetPrevSongOfUser) Calls() []*PlaylistRepositoryMockGetPrevSongOfUserParams {
	mmGetPrevSongOfUser.mutex.RLock()

	argCopy := make([]*PlaylistRepositoryMockGetPrevSongOfUserParams, len(mmGetPrevSongOfUser.callArgs))
	copy(argCopy, mmGetPrevSongOfUser.callArgs)

	mmGetPrevSongOfUser.mutex.RUnlock()

	return argCopy
}

// MinimockGetPrevSongOfUserDone returns true if the count of the GetPrevSongOfUser invocations corresponds
// the number of defined expectations
func (m *PlaylistRepositoryMock) MinimockGetPrevSongOfUserDone() bool {
	if m.GetPrevSongOfUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPrevSongOfUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPrevSongOfUserMock.invocationsDone()
}

// MinimockGetPrevSongOfUserInspect logs each unmet expectation
func (m *PlaylistRepositoryMock) MinimockGetPrevSongOfUserInspect() {
	for _, e := range m.GetPrevSongOfUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PlaylistRepositoryMock.GetPrevSongOfUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPrevSongOfUserCounter := mm_atomic.LoadUint64(&m.afterGetPrevSongOfUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPrevSongOfUserMock.defaultExpectation != nil && afterGetPrevSongOfUserCounter < 1 {
		if m.GetPrevSongOfUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PlaylistRepositoryMock.GetPrevSongOfUser at\n%s", m.GetPrevSongOfUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PlaylistRepositoryMock.GetPrevSongOfUser at\n%s with params: %#v", m.GetPrevSongOfUserMock.defaultExpectation.expectationOrigins.origin, *m.GetPrevSongOfUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPrevSongOfUser != nil && afterGetPrevSongOfUserCounter < 1 {
		m.t.Errorf("Expected call to PlaylistRepositoryMock.GetPrevSongOfUser at\n%s", m.funcGetPrevSongOfUserOrigin)
	}

	if !m.GetPrevSongOfUserMock.invocationsDone() && afterGetPrevSongOfUserCounter > 0 {
		m.t.Errorf("Expected %d calls to PlaylistRepositoryMock.GetPrevSongOfUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPrevSongOfUserMock.expectedInvocations), m.GetPrevSongOfUserMock.expectedInvocationsOrigin, afterGetPrevSongOfUserCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PlaylistRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddSongInspect()

			m.MinimockDeleteSongInspect()

			m.MinimockGetFirstSongOfUserInspect()

			m.MinimockGetNextSongOfUserInspect()

			m.MinimockGetPrevSongOfUserInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PlaylistRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PlaylistRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddSongDone() &&
		m.MinimockDeleteSongDone() &&
		m.MinimockGetFirstSongOfUserDone() &&
		m.MinimockGetNextSongOfUserDone() &&
		m.MinimockGetPrevSongOfUserDone()
}
