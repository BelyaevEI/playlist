// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/BelyaevEI/playlist/internal/service/playlist.PlaylistService -o playlist_service_minimock.go -n PlaylistServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/BelyaevEI/playlist/internal/model"
	"github.com/gojuno/minimock/v3"
)

// PlaylistServiceMock implements mm_playlist.PlaylistService
type PlaylistServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddSong          func(ctx context.Context, song *model.SongRequest) (err error)
	funcAddSongOrigin    string
	inspectFuncAddSong   func(ctx context.Context, song *model.SongRequest)
	afterAddSongCounter  uint64
	beforeAddSongCounter uint64
	AddSongMock          mPlaylistServiceMockAddSong

	funcCloseActionCH          func()
	funcCloseActionCHOrigin    string
	inspectFuncCloseActionCH   func()
	afterCloseActionCHCounter  uint64
	beforeCloseActionCHCounter uint64
	CloseActionCHMock          mPlaylistServiceMockCloseActionCH

	funcDeleteSong          func(ctx context.Context, song *model.SongRequest) (err error)
	funcDeleteSongOrigin    string
	inspectFuncDeleteSong   func(ctx context.Context, song *model.SongRequest)
	afterDeleteSongCounter  uint64
	beforeDeleteSongCounter uint64
	DeleteSongMock          mPlaylistServiceMockDeleteSong

	funcNextSong          func(ctx context.Context, login string)
	funcNextSongOrigin    string
	inspectFuncNextSong   func(ctx context.Context, login string)
	afterNextSongCounter  uint64
	beforeNextSongCounter uint64
	NextSongMock          mPlaylistServiceMockNextSong

	funcPauseSong          func(ctx context.Context, login string)
	funcPauseSongOrigin    string
	inspectFuncPauseSong   func(ctx context.Context, login string)
	afterPauseSongCounter  uint64
	beforePauseSongCounter uint64
	PauseSongMock          mPlaylistServiceMockPauseSong

	funcPlaySong          func(ctx context.Context, login string)
	funcPlaySongOrigin    string
	inspectFuncPlaySong   func(ctx context.Context, login string)
	afterPlaySongCounter  uint64
	beforePlaySongCounter uint64
	PlaySongMock          mPlaylistServiceMockPlaySong

	funcPrevSong          func(ctx context.Context, login string)
	funcPrevSongOrigin    string
	inspectFuncPrevSong   func(ctx context.Context, login string)
	afterPrevSongCounter  uint64
	beforePrevSongCounter uint64
	PrevSongMock          mPlaylistServiceMockPrevSong

	funcStartPlayback          func(ctx context.Context, login string, wg *sync.WaitGroup)
	funcStartPlaybackOrigin    string
	inspectFuncStartPlayback   func(ctx context.Context, login string, wg *sync.WaitGroup)
	afterStartPlaybackCounter  uint64
	beforeStartPlaybackCounter uint64
	StartPlaybackMock          mPlaylistServiceMockStartPlayback
}

// NewPlaylistServiceMock returns a mock for mm_playlist.PlaylistService
func NewPlaylistServiceMock(t minimock.Tester) *PlaylistServiceMock {
	m := &PlaylistServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddSongMock = mPlaylistServiceMockAddSong{mock: m}
	m.AddSongMock.callArgs = []*PlaylistServiceMockAddSongParams{}

	m.CloseActionCHMock = mPlaylistServiceMockCloseActionCH{mock: m}

	m.DeleteSongMock = mPlaylistServiceMockDeleteSong{mock: m}
	m.DeleteSongMock.callArgs = []*PlaylistServiceMockDeleteSongParams{}

	m.NextSongMock = mPlaylistServiceMockNextSong{mock: m}
	m.NextSongMock.callArgs = []*PlaylistServiceMockNextSongParams{}

	m.PauseSongMock = mPlaylistServiceMockPauseSong{mock: m}
	m.PauseSongMock.callArgs = []*PlaylistServiceMockPauseSongParams{}

	m.PlaySongMock = mPlaylistServiceMockPlaySong{mock: m}
	m.PlaySongMock.callArgs = []*PlaylistServiceMockPlaySongParams{}

	m.PrevSongMock = mPlaylistServiceMockPrevSong{mock: m}
	m.PrevSongMock.callArgs = []*PlaylistServiceMockPrevSongParams{}

	m.StartPlaybackMock = mPlaylistServiceMockStartPlayback{mock: m}
	m.StartPlaybackMock.callArgs = []*PlaylistServiceMockStartPlaybackParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mPlaylistServiceMockAddSong struct {
	optional           bool
	mock               *PlaylistServiceMock
	defaultExpectation *PlaylistServiceMockAddSongExpectation
	expectations       []*PlaylistServiceMockAddSongExpectation

	callArgs []*PlaylistServiceMockAddSongParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PlaylistServiceMockAddSongExpectation specifies expectation struct of the PlaylistService.AddSong
type PlaylistServiceMockAddSongExpectation struct {
	mock               *PlaylistServiceMock
	params             *PlaylistServiceMockAddSongParams
	paramPtrs          *PlaylistServiceMockAddSongParamPtrs
	expectationOrigins PlaylistServiceMockAddSongExpectationOrigins
	results            *PlaylistServiceMockAddSongResults
	returnOrigin       string
	Counter            uint64
}

// PlaylistServiceMockAddSongParams contains parameters of the PlaylistService.AddSong
type PlaylistServiceMockAddSongParams struct {
	ctx  context.Context
	song *model.SongRequest
}

// PlaylistServiceMockAddSongParamPtrs contains pointers to parameters of the PlaylistService.AddSong
type PlaylistServiceMockAddSongParamPtrs struct {
	ctx  *context.Context
	song **model.SongRequest
}

// PlaylistServiceMockAddSongResults contains results of the PlaylistService.AddSong
type PlaylistServiceMockAddSongResults struct {
	err error
}

// PlaylistServiceMockAddSongOrigins contains origins of expectations of the PlaylistService.AddSong
type PlaylistServiceMockAddSongExpectationOrigins struct {
	origin     string
	originCtx  string
	originSong string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddSong *mPlaylistServiceMockAddSong) Optional() *mPlaylistServiceMockAddSong {
	mmAddSong.optional = true
	return mmAddSong
}

// Expect sets up expected params for PlaylistService.AddSong
func (mmAddSong *mPlaylistServiceMockAddSong) Expect(ctx context.Context, song *model.SongRequest) *mPlaylistServiceMockAddSong {
	if mmAddSong.mock.funcAddSong != nil {
		mmAddSong.mock.t.Fatalf("PlaylistServiceMock.AddSong mock is already set by Set")
	}

	if mmAddSong.defaultExpectation == nil {
		mmAddSong.defaultExpectation = &PlaylistServiceMockAddSongExpectation{}
	}

	if mmAddSong.defaultExpectation.paramPtrs != nil {
		mmAddSong.mock.t.Fatalf("PlaylistServiceMock.AddSong mock is already set by ExpectParams functions")
	}

	mmAddSong.defaultExpectation.params = &PlaylistServiceMockAddSongParams{ctx, song}
	mmAddSong.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddSong.expectations {
		if minimock.Equal(e.params, mmAddSong.defaultExpectation.params) {
			mmAddSong.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddSong.defaultExpectation.params)
		}
	}

	return mmAddSong
}

// ExpectCtxParam1 sets up expected param ctx for PlaylistService.AddSong
func (mmAddSong *mPlaylistServiceMockAddSong) ExpectCtxParam1(ctx context.Context) *mPlaylistServiceMockAddSong {
	if mmAddSong.mock.funcAddSong != nil {
		mmAddSong.mock.t.Fatalf("PlaylistServiceMock.AddSong mock is already set by Set")
	}

	if mmAddSong.defaultExpectation == nil {
		mmAddSong.defaultExpectation = &PlaylistServiceMockAddSongExpectation{}
	}

	if mmAddSong.defaultExpectation.params != nil {
		mmAddSong.mock.t.Fatalf("PlaylistServiceMock.AddSong mock is already set by Expect")
	}

	if mmAddSong.defaultExpectation.paramPtrs == nil {
		mmAddSong.defaultExpectation.paramPtrs = &PlaylistServiceMockAddSongParamPtrs{}
	}
	mmAddSong.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddSong.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddSong
}

// ExpectSongParam2 sets up expected param song for PlaylistService.AddSong
func (mmAddSong *mPlaylistServiceMockAddSong) ExpectSongParam2(song *model.SongRequest) *mPlaylistServiceMockAddSong {
	if mmAddSong.mock.funcAddSong != nil {
		mmAddSong.mock.t.Fatalf("PlaylistServiceMock.AddSong mock is already set by Set")
	}

	if mmAddSong.defaultExpectation == nil {
		mmAddSong.defaultExpectation = &PlaylistServiceMockAddSongExpectation{}
	}

	if mmAddSong.defaultExpectation.params != nil {
		mmAddSong.mock.t.Fatalf("PlaylistServiceMock.AddSong mock is already set by Expect")
	}

	if mmAddSong.defaultExpectation.paramPtrs == nil {
		mmAddSong.defaultExpectation.paramPtrs = &PlaylistServiceMockAddSongParamPtrs{}
	}
	mmAddSong.defaultExpectation.paramPtrs.song = &song
	mmAddSong.defaultExpectation.expectationOrigins.originSong = minimock.CallerInfo(1)

	return mmAddSong
}

// Inspect accepts an inspector function that has same arguments as the PlaylistService.AddSong
func (mmAddSong *mPlaylistServiceMockAddSong) Inspect(f func(ctx context.Context, song *model.SongRequest)) *mPlaylistServiceMockAddSong {
	if mmAddSong.mock.inspectFuncAddSong != nil {
		mmAddSong.mock.t.Fatalf("Inspect function is already set for PlaylistServiceMock.AddSong")
	}

	mmAddSong.mock.inspectFuncAddSong = f

	return mmAddSong
}

// Return sets up results that will be returned by PlaylistService.AddSong
func (mmAddSong *mPlaylistServiceMockAddSong) Return(err error) *PlaylistServiceMock {
	if mmAddSong.mock.funcAddSong != nil {
		mmAddSong.mock.t.Fatalf("PlaylistServiceMock.AddSong mock is already set by Set")
	}

	if mmAddSong.defaultExpectation == nil {
		mmAddSong.defaultExpectation = &PlaylistServiceMockAddSongExpectation{mock: mmAddSong.mock}
	}
	mmAddSong.defaultExpectation.results = &PlaylistServiceMockAddSongResults{err}
	mmAddSong.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddSong.mock
}

// Set uses given function f to mock the PlaylistService.AddSong method
func (mmAddSong *mPlaylistServiceMockAddSong) Set(f func(ctx context.Context, song *model.SongRequest) (err error)) *PlaylistServiceMock {
	if mmAddSong.defaultExpectation != nil {
		mmAddSong.mock.t.Fatalf("Default expectation is already set for the PlaylistService.AddSong method")
	}

	if len(mmAddSong.expectations) > 0 {
		mmAddSong.mock.t.Fatalf("Some expectations are already set for the PlaylistService.AddSong method")
	}

	mmAddSong.mock.funcAddSong = f
	mmAddSong.mock.funcAddSongOrigin = minimock.CallerInfo(1)
	return mmAddSong.mock
}

// When sets expectation for the PlaylistService.AddSong which will trigger the result defined by the following
// Then helper
func (mmAddSong *mPlaylistServiceMockAddSong) When(ctx context.Context, song *model.SongRequest) *PlaylistServiceMockAddSongExpectation {
	if mmAddSong.mock.funcAddSong != nil {
		mmAddSong.mock.t.Fatalf("PlaylistServiceMock.AddSong mock is already set by Set")
	}

	expectation := &PlaylistServiceMockAddSongExpectation{
		mock:               mmAddSong.mock,
		params:             &PlaylistServiceMockAddSongParams{ctx, song},
		expectationOrigins: PlaylistServiceMockAddSongExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddSong.expectations = append(mmAddSong.expectations, expectation)
	return expectation
}

// Then sets up PlaylistService.AddSong return parameters for the expectation previously defined by the When method
func (e *PlaylistServiceMockAddSongExpectation) Then(err error) *PlaylistServiceMock {
	e.results = &PlaylistServiceMockAddSongResults{err}
	return e.mock
}

// Times sets number of times PlaylistService.AddSong should be invoked
func (mmAddSong *mPlaylistServiceMockAddSong) Times(n uint64) *mPlaylistServiceMockAddSong {
	if n == 0 {
		mmAddSong.mock.t.Fatalf("Times of PlaylistServiceMock.AddSong mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddSong.expectedInvocations, n)
	mmAddSong.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddSong
}

func (mmAddSong *mPlaylistServiceMockAddSong) invocationsDone() bool {
	if len(mmAddSong.expectations) == 0 && mmAddSong.defaultExpectation == nil && mmAddSong.mock.funcAddSong == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddSong.mock.afterAddSongCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddSong.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddSong implements mm_playlist.PlaylistService
func (mmAddSong *PlaylistServiceMock) AddSong(ctx context.Context, song *model.SongRequest) (err error) {
	mm_atomic.AddUint64(&mmAddSong.beforeAddSongCounter, 1)
	defer mm_atomic.AddUint64(&mmAddSong.afterAddSongCounter, 1)

	mmAddSong.t.Helper()

	if mmAddSong.inspectFuncAddSong != nil {
		mmAddSong.inspectFuncAddSong(ctx, song)
	}

	mm_params := PlaylistServiceMockAddSongParams{ctx, song}

	// Record call args
	mmAddSong.AddSongMock.mutex.Lock()
	mmAddSong.AddSongMock.callArgs = append(mmAddSong.AddSongMock.callArgs, &mm_params)
	mmAddSong.AddSongMock.mutex.Unlock()

	for _, e := range mmAddSong.AddSongMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddSong.AddSongMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddSong.AddSongMock.defaultExpectation.Counter, 1)
		mm_want := mmAddSong.AddSongMock.defaultExpectation.params
		mm_want_ptrs := mmAddSong.AddSongMock.defaultExpectation.paramPtrs

		mm_got := PlaylistServiceMockAddSongParams{ctx, song}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddSong.t.Errorf("PlaylistServiceMock.AddSong got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddSong.AddSongMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.song != nil && !minimock.Equal(*mm_want_ptrs.song, mm_got.song) {
				mmAddSong.t.Errorf("PlaylistServiceMock.AddSong got unexpected parameter song, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddSong.AddSongMock.defaultExpectation.expectationOrigins.originSong, *mm_want_ptrs.song, mm_got.song, minimock.Diff(*mm_want_ptrs.song, mm_got.song))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddSong.t.Errorf("PlaylistServiceMock.AddSong got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddSong.AddSongMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddSong.AddSongMock.defaultExpectation.results
		if mm_results == nil {
			mmAddSong.t.Fatal("No results are set for the PlaylistServiceMock.AddSong")
		}
		return (*mm_results).err
	}
	if mmAddSong.funcAddSong != nil {
		return mmAddSong.funcAddSong(ctx, song)
	}
	mmAddSong.t.Fatalf("Unexpected call to PlaylistServiceMock.AddSong. %v %v", ctx, song)
	return
}

// AddSongAfterCounter returns a count of finished PlaylistServiceMock.AddSong invocations
func (mmAddSong *PlaylistServiceMock) AddSongAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddSong.afterAddSongCounter)
}

// AddSongBeforeCounter returns a count of PlaylistServiceMock.AddSong invocations
func (mmAddSong *PlaylistServiceMock) AddSongBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddSong.beforeAddSongCounter)
}

// Calls returns a list of arguments used in each call to PlaylistServiceMock.AddSong.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddSong *mPlaylistServiceMockAddSong) Calls() []*PlaylistServiceMockAddSongParams {
	mmAddSong.mutex.RLock()

	argCopy := make([]*PlaylistServiceMockAddSongParams, len(mmAddSong.callArgs))
	copy(argCopy, mmAddSong.callArgs)

	mmAddSong.mutex.RUnlock()

	return argCopy
}

// MinimockAddSongDone returns true if the count of the AddSong invocations corresponds
// the number of defined expectations
func (m *PlaylistServiceMock) MinimockAddSongDone() bool {
	if m.AddSongMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddSongMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddSongMock.invocationsDone()
}

// MinimockAddSongInspect logs each unmet expectation
func (m *PlaylistServiceMock) MinimockAddSongInspect() {
	for _, e := range m.AddSongMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PlaylistServiceMock.AddSong at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddSongCounter := mm_atomic.LoadUint64(&m.afterAddSongCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddSongMock.defaultExpectation != nil && afterAddSongCounter < 1 {
		if m.AddSongMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PlaylistServiceMock.AddSong at\n%s", m.AddSongMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PlaylistServiceMock.AddSong at\n%s with params: %#v", m.AddSongMock.defaultExpectation.expectationOrigins.origin, *m.AddSongMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddSong != nil && afterAddSongCounter < 1 {
		m.t.Errorf("Expected call to PlaylistServiceMock.AddSong at\n%s", m.funcAddSongOrigin)
	}

	if !m.AddSongMock.invocationsDone() && afterAddSongCounter > 0 {
		m.t.Errorf("Expected %d calls to PlaylistServiceMock.AddSong at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddSongMock.expectedInvocations), m.AddSongMock.expectedInvocationsOrigin, afterAddSongCounter)
	}
}

type mPlaylistServiceMockCloseActionCH struct {
	optional           bool
	mock               *PlaylistServiceMock
	defaultExpectation *PlaylistServiceMockCloseActionCHExpectation
	expectations       []*PlaylistServiceMockCloseActionCHExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PlaylistServiceMockCloseActionCHExpectation specifies expectation struct of the PlaylistService.CloseActionCH
type PlaylistServiceMockCloseActionCHExpectation struct {
	mock *PlaylistServiceMock

	returnOrigin string
	Counter      uint64
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCloseActionCH *mPlaylistServiceMockCloseActionCH) Optional() *mPlaylistServiceMockCloseActionCH {
	mmCloseActionCH.optional = true
	return mmCloseActionCH
}

// Expect sets up expected params for PlaylistService.CloseActionCH
func (mmCloseActionCH *mPlaylistServiceMockCloseActionCH) Expect() *mPlaylistServiceMockCloseActionCH {
	if mmCloseActionCH.mock.funcCloseActionCH != nil {
		mmCloseActionCH.mock.t.Fatalf("PlaylistServiceMock.CloseActionCH mock is already set by Set")
	}

	if mmCloseActionCH.defaultExpectation == nil {
		mmCloseActionCH.defaultExpectation = &PlaylistServiceMockCloseActionCHExpectation{}
	}

	return mmCloseActionCH
}

// Inspect accepts an inspector function that has same arguments as the PlaylistService.CloseActionCH
func (mmCloseActionCH *mPlaylistServiceMockCloseActionCH) Inspect(f func()) *mPlaylistServiceMockCloseActionCH {
	if mmCloseActionCH.mock.inspectFuncCloseActionCH != nil {
		mmCloseActionCH.mock.t.Fatalf("Inspect function is already set for PlaylistServiceMock.CloseActionCH")
	}

	mmCloseActionCH.mock.inspectFuncCloseActionCH = f

	return mmCloseActionCH
}

// Return sets up results that will be returned by PlaylistService.CloseActionCH
func (mmCloseActionCH *mPlaylistServiceMockCloseActionCH) Return() *PlaylistServiceMock {
	if mmCloseActionCH.mock.funcCloseActionCH != nil {
		mmCloseActionCH.mock.t.Fatalf("PlaylistServiceMock.CloseActionCH mock is already set by Set")
	}

	if mmCloseActionCH.defaultExpectation == nil {
		mmCloseActionCH.defaultExpectation = &PlaylistServiceMockCloseActionCHExpectation{mock: mmCloseActionCH.mock}
	}

	mmCloseActionCH.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCloseActionCH.mock
}

// Set uses given function f to mock the PlaylistService.CloseActionCH method
func (mmCloseActionCH *mPlaylistServiceMockCloseActionCH) Set(f func()) *PlaylistServiceMock {
	if mmCloseActionCH.defaultExpectation != nil {
		mmCloseActionCH.mock.t.Fatalf("Default expectation is already set for the PlaylistService.CloseActionCH method")
	}

	if len(mmCloseActionCH.expectations) > 0 {
		mmCloseActionCH.mock.t.Fatalf("Some expectations are already set for the PlaylistService.CloseActionCH method")
	}

	mmCloseActionCH.mock.funcCloseActionCH = f
	mmCloseActionCH.mock.funcCloseActionCHOrigin = minimock.CallerInfo(1)
	return mmCloseActionCH.mock
}

// Times sets number of times PlaylistService.CloseActionCH should be invoked
func (mmCloseActionCH *mPlaylistServiceMockCloseActionCH) Times(n uint64) *mPlaylistServiceMockCloseActionCH {
	if n == 0 {
		mmCloseActionCH.mock.t.Fatalf("Times of PlaylistServiceMock.CloseActionCH mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCloseActionCH.expectedInvocations, n)
	mmCloseActionCH.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCloseActionCH
}

func (mmCloseActionCH *mPlaylistServiceMockCloseActionCH) invocationsDone() bool {
	if len(mmCloseActionCH.expectations) == 0 && mmCloseActionCH.defaultExpectation == nil && mmCloseActionCH.mock.funcCloseActionCH == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCloseActionCH.mock.afterCloseActionCHCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCloseActionCH.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CloseActionCH implements mm_playlist.PlaylistService
func (mmCloseActionCH *PlaylistServiceMock) CloseActionCH() {
	mm_atomic.AddUint64(&mmCloseActionCH.beforeCloseActionCHCounter, 1)
	defer mm_atomic.AddUint64(&mmCloseActionCH.afterCloseActionCHCounter, 1)

	mmCloseActionCH.t.Helper()

	if mmCloseActionCH.inspectFuncCloseActionCH != nil {
		mmCloseActionCH.inspectFuncCloseActionCH()
	}

	if mmCloseActionCH.CloseActionCHMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCloseActionCH.CloseActionCHMock.defaultExpectation.Counter, 1)

		return

	}
	if mmCloseActionCH.funcCloseActionCH != nil {
		mmCloseActionCH.funcCloseActionCH()
		return
	}
	mmCloseActionCH.t.Fatalf("Unexpected call to PlaylistServiceMock.CloseActionCH.")

}

// CloseActionCHAfterCounter returns a count of finished PlaylistServiceMock.CloseActionCH invocations
func (mmCloseActionCH *PlaylistServiceMock) CloseActionCHAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCloseActionCH.afterCloseActionCHCounter)
}

// CloseActionCHBeforeCounter returns a count of PlaylistServiceMock.CloseActionCH invocations
func (mmCloseActionCH *PlaylistServiceMock) CloseActionCHBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCloseActionCH.beforeCloseActionCHCounter)
}

// MinimockCloseActionCHDone returns true if the count of the CloseActionCH invocations corresponds
// the number of defined expectations
func (m *PlaylistServiceMock) MinimockCloseActionCHDone() bool {
	if m.CloseActionCHMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CloseActionCHMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CloseActionCHMock.invocationsDone()
}

// MinimockCloseActionCHInspect logs each unmet expectation
func (m *PlaylistServiceMock) MinimockCloseActionCHInspect() {
	for _, e := range m.CloseActionCHMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to PlaylistServiceMock.CloseActionCH")
		}
	}

	afterCloseActionCHCounter := mm_atomic.LoadUint64(&m.afterCloseActionCHCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CloseActionCHMock.defaultExpectation != nil && afterCloseActionCHCounter < 1 {
		m.t.Errorf("Expected call to PlaylistServiceMock.CloseActionCH at\n%s", m.CloseActionCHMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCloseActionCH != nil && afterCloseActionCHCounter < 1 {
		m.t.Errorf("Expected call to PlaylistServiceMock.CloseActionCH at\n%s", m.funcCloseActionCHOrigin)
	}

	if !m.CloseActionCHMock.invocationsDone() && afterCloseActionCHCounter > 0 {
		m.t.Errorf("Expected %d calls to PlaylistServiceMock.CloseActionCH at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CloseActionCHMock.expectedInvocations), m.CloseActionCHMock.expectedInvocationsOrigin, afterCloseActionCHCounter)
	}
}

type mPlaylistServiceMockDeleteSong struct {
	optional           bool
	mock               *PlaylistServiceMock
	defaultExpectation *PlaylistServiceMockDeleteSongExpectation
	expectations       []*PlaylistServiceMockDeleteSongExpectation

	callArgs []*PlaylistServiceMockDeleteSongParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PlaylistServiceMockDeleteSongExpectation specifies expectation struct of the PlaylistService.DeleteSong
type PlaylistServiceMockDeleteSongExpectation struct {
	mock               *PlaylistServiceMock
	params             *PlaylistServiceMockDeleteSongParams
	paramPtrs          *PlaylistServiceMockDeleteSongParamPtrs
	expectationOrigins PlaylistServiceMockDeleteSongExpectationOrigins
	results            *PlaylistServiceMockDeleteSongResults
	returnOrigin       string
	Counter            uint64
}

// PlaylistServiceMockDeleteSongParams contains parameters of the PlaylistService.DeleteSong
type PlaylistServiceMockDeleteSongParams struct {
	ctx  context.Context
	song *model.SongRequest
}

// PlaylistServiceMockDeleteSongParamPtrs contains pointers to parameters of the PlaylistService.DeleteSong
type PlaylistServiceMockDeleteSongParamPtrs struct {
	ctx  *context.Context
	song **model.SongRequest
}

// PlaylistServiceMockDeleteSongResults contains results of the PlaylistService.DeleteSong
type PlaylistServiceMockDeleteSongResults struct {
	err error
}

// PlaylistServiceMockDeleteSongOrigins contains origins of expectations of the PlaylistService.DeleteSong
type PlaylistServiceMockDeleteSongExpectationOrigins struct {
	origin     string
	originCtx  string
	originSong string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteSong *mPlaylistServiceMockDeleteSong) Optional() *mPlaylistServiceMockDeleteSong {
	mmDeleteSong.optional = true
	return mmDeleteSong
}

// Expect sets up expected params for PlaylistService.DeleteSong
func (mmDeleteSong *mPlaylistServiceMockDeleteSong) Expect(ctx context.Context, song *model.SongRequest) *mPlaylistServiceMockDeleteSong {
	if mmDeleteSong.mock.funcDeleteSong != nil {
		mmDeleteSong.mock.t.Fatalf("PlaylistServiceMock.DeleteSong mock is already set by Set")
	}

	if mmDeleteSong.defaultExpectation == nil {
		mmDeleteSong.defaultExpectation = &PlaylistServiceMockDeleteSongExpectation{}
	}

	if mmDeleteSong.defaultExpectation.paramPtrs != nil {
		mmDeleteSong.mock.t.Fatalf("PlaylistServiceMock.DeleteSong mock is already set by ExpectParams functions")
	}

	mmDeleteSong.defaultExpectation.params = &PlaylistServiceMockDeleteSongParams{ctx, song}
	mmDeleteSong.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteSong.expectations {
		if minimock.Equal(e.params, mmDeleteSong.defaultExpectation.params) {
			mmDeleteSong.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteSong.defaultExpectation.params)
		}
	}

	return mmDeleteSong
}

// ExpectCtxParam1 sets up expected param ctx for PlaylistService.DeleteSong
func (mmDeleteSong *mPlaylistServiceMockDeleteSong) ExpectCtxParam1(ctx context.Context) *mPlaylistServiceMockDeleteSong {
	if mmDeleteSong.mock.funcDeleteSong != nil {
		mmDeleteSong.mock.t.Fatalf("PlaylistServiceMock.DeleteSong mock is already set by Set")
	}

	if mmDeleteSong.defaultExpectation == nil {
		mmDeleteSong.defaultExpectation = &PlaylistServiceMockDeleteSongExpectation{}
	}

	if mmDeleteSong.defaultExpectation.params != nil {
		mmDeleteSong.mock.t.Fatalf("PlaylistServiceMock.DeleteSong mock is already set by Expect")
	}

	if mmDeleteSong.defaultExpectation.paramPtrs == nil {
		mmDeleteSong.defaultExpectation.paramPtrs = &PlaylistServiceMockDeleteSongParamPtrs{}
	}
	mmDeleteSong.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteSong.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteSong
}

// ExpectSongParam2 sets up expected param song for PlaylistService.DeleteSong
func (mmDeleteSong *mPlaylistServiceMockDeleteSong) ExpectSongParam2(song *model.SongRequest) *mPlaylistServiceMockDeleteSong {
	if mmDeleteSong.mock.funcDeleteSong != nil {
		mmDeleteSong.mock.t.Fatalf("PlaylistServiceMock.DeleteSong mock is already set by Set")
	}

	if mmDeleteSong.defaultExpectation == nil {
		mmDeleteSong.defaultExpectation = &PlaylistServiceMockDeleteSongExpectation{}
	}

	if mmDeleteSong.defaultExpectation.params != nil {
		mmDeleteSong.mock.t.Fatalf("PlaylistServiceMock.DeleteSong mock is already set by Expect")
	}

	if mmDeleteSong.defaultExpectation.paramPtrs == nil {
		mmDeleteSong.defaultExpectation.paramPtrs = &PlaylistServiceMockDeleteSongParamPtrs{}
	}
	mmDeleteSong.defaultExpectation.paramPtrs.song = &song
	mmDeleteSong.defaultExpectation.expectationOrigins.originSong = minimock.CallerInfo(1)

	return mmDeleteSong
}

// Inspect accepts an inspector function that has same arguments as the PlaylistService.DeleteSong
func (mmDeleteSong *mPlaylistServiceMockDeleteSong) Inspect(f func(ctx context.Context, song *model.SongRequest)) *mPlaylistServiceMockDeleteSong {
	if mmDeleteSong.mock.inspectFuncDeleteSong != nil {
		mmDeleteSong.mock.t.Fatalf("Inspect function is already set for PlaylistServiceMock.DeleteSong")
	}

	mmDeleteSong.mock.inspectFuncDeleteSong = f

	return mmDeleteSong
}

// Return sets up results that will be returned by PlaylistService.DeleteSong
func (mmDeleteSong *mPlaylistServiceMockDeleteSong) Return(err error) *PlaylistServiceMock {
	if mmDeleteSong.mock.funcDeleteSong != nil {
		mmDeleteSong.mock.t.Fatalf("PlaylistServiceMock.DeleteSong mock is already set by Set")
	}

	if mmDeleteSong.defaultExpectation == nil {
		mmDeleteSong.defaultExpectation = &PlaylistServiceMockDeleteSongExpectation{mock: mmDeleteSong.mock}
	}
	mmDeleteSong.defaultExpectation.results = &PlaylistServiceMockDeleteSongResults{err}
	mmDeleteSong.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteSong.mock
}

// Set uses given function f to mock the PlaylistService.DeleteSong method
func (mmDeleteSong *mPlaylistServiceMockDeleteSong) Set(f func(ctx context.Context, song *model.SongRequest) (err error)) *PlaylistServiceMock {
	if mmDeleteSong.defaultExpectation != nil {
		mmDeleteSong.mock.t.Fatalf("Default expectation is already set for the PlaylistService.DeleteSong method")
	}

	if len(mmDeleteSong.expectations) > 0 {
		mmDeleteSong.mock.t.Fatalf("Some expectations are already set for the PlaylistService.DeleteSong method")
	}

	mmDeleteSong.mock.funcDeleteSong = f
	mmDeleteSong.mock.funcDeleteSongOrigin = minimock.CallerInfo(1)
	return mmDeleteSong.mock
}

// When sets expectation for the PlaylistService.DeleteSong which will trigger the result defined by the following
// Then helper
func (mmDeleteSong *mPlaylistServiceMockDeleteSong) When(ctx context.Context, song *model.SongRequest) *PlaylistServiceMockDeleteSongExpectation {
	if mmDeleteSong.mock.funcDeleteSong != nil {
		mmDeleteSong.mock.t.Fatalf("PlaylistServiceMock.DeleteSong mock is already set by Set")
	}

	expectation := &PlaylistServiceMockDeleteSongExpectation{
		mock:               mmDeleteSong.mock,
		params:             &PlaylistServiceMockDeleteSongParams{ctx, song},
		expectationOrigins: PlaylistServiceMockDeleteSongExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteSong.expectations = append(mmDeleteSong.expectations, expectation)
	return expectation
}

// Then sets up PlaylistService.DeleteSong return parameters for the expectation previously defined by the When method
func (e *PlaylistServiceMockDeleteSongExpectation) Then(err error) *PlaylistServiceMock {
	e.results = &PlaylistServiceMockDeleteSongResults{err}
	return e.mock
}

// Times sets number of times PlaylistService.DeleteSong should be invoked
func (mmDeleteSong *mPlaylistServiceMockDeleteSong) Times(n uint64) *mPlaylistServiceMockDeleteSong {
	if n == 0 {
		mmDeleteSong.mock.t.Fatalf("Times of PlaylistServiceMock.DeleteSong mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteSong.expectedInvocations, n)
	mmDeleteSong.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteSong
}

func (mmDeleteSong *mPlaylistServiceMockDeleteSong) invocationsDone() bool {
	if len(mmDeleteSong.expectations) == 0 && mmDeleteSong.defaultExpectation == nil && mmDeleteSong.mock.funcDeleteSong == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteSong.mock.afterDeleteSongCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteSong.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteSong implements mm_playlist.PlaylistService
func (mmDeleteSong *PlaylistServiceMock) DeleteSong(ctx context.Context, song *model.SongRequest) (err error) {
	mm_atomic.AddUint64(&mmDeleteSong.beforeDeleteSongCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteSong.afterDeleteSongCounter, 1)

	mmDeleteSong.t.Helper()

	if mmDeleteSong.inspectFuncDeleteSong != nil {
		mmDeleteSong.inspectFuncDeleteSong(ctx, song)
	}

	mm_params := PlaylistServiceMockDeleteSongParams{ctx, song}

	// Record call args
	mmDeleteSong.DeleteSongMock.mutex.Lock()
	mmDeleteSong.DeleteSongMock.callArgs = append(mmDeleteSong.DeleteSongMock.callArgs, &mm_params)
	mmDeleteSong.DeleteSongMock.mutex.Unlock()

	for _, e := range mmDeleteSong.DeleteSongMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteSong.DeleteSongMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteSong.DeleteSongMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteSong.DeleteSongMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteSong.DeleteSongMock.defaultExpectation.paramPtrs

		mm_got := PlaylistServiceMockDeleteSongParams{ctx, song}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteSong.t.Errorf("PlaylistServiceMock.DeleteSong got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteSong.DeleteSongMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.song != nil && !minimock.Equal(*mm_want_ptrs.song, mm_got.song) {
				mmDeleteSong.t.Errorf("PlaylistServiceMock.DeleteSong got unexpected parameter song, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteSong.DeleteSongMock.defaultExpectation.expectationOrigins.originSong, *mm_want_ptrs.song, mm_got.song, minimock.Diff(*mm_want_ptrs.song, mm_got.song))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteSong.t.Errorf("PlaylistServiceMock.DeleteSong got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteSong.DeleteSongMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteSong.DeleteSongMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteSong.t.Fatal("No results are set for the PlaylistServiceMock.DeleteSong")
		}
		return (*mm_results).err
	}
	if mmDeleteSong.funcDeleteSong != nil {
		return mmDeleteSong.funcDeleteSong(ctx, song)
	}
	mmDeleteSong.t.Fatalf("Unexpected call to PlaylistServiceMock.DeleteSong. %v %v", ctx, song)
	return
}

// DeleteSongAfterCounter returns a count of finished PlaylistServiceMock.DeleteSong invocations
func (mmDeleteSong *PlaylistServiceMock) DeleteSongAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSong.afterDeleteSongCounter)
}

// DeleteSongBeforeCounter returns a count of PlaylistServiceMock.DeleteSong invocations
func (mmDeleteSong *PlaylistServiceMock) DeleteSongBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSong.beforeDeleteSongCounter)
}

// Calls returns a list of arguments used in each call to PlaylistServiceMock.DeleteSong.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteSong *mPlaylistServiceMockDeleteSong) Calls() []*PlaylistServiceMockDeleteSongParams {
	mmDeleteSong.mutex.RLock()

	argCopy := make([]*PlaylistServiceMockDeleteSongParams, len(mmDeleteSong.callArgs))
	copy(argCopy, mmDeleteSong.callArgs)

	mmDeleteSong.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteSongDone returns true if the count of the DeleteSong invocations corresponds
// the number of defined expectations
func (m *PlaylistServiceMock) MinimockDeleteSongDone() bool {
	if m.DeleteSongMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteSongMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteSongMock.invocationsDone()
}

// MinimockDeleteSongInspect logs each unmet expectation
func (m *PlaylistServiceMock) MinimockDeleteSongInspect() {
	for _, e := range m.DeleteSongMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PlaylistServiceMock.DeleteSong at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteSongCounter := mm_atomic.LoadUint64(&m.afterDeleteSongCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteSongMock.defaultExpectation != nil && afterDeleteSongCounter < 1 {
		if m.DeleteSongMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PlaylistServiceMock.DeleteSong at\n%s", m.DeleteSongMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PlaylistServiceMock.DeleteSong at\n%s with params: %#v", m.DeleteSongMock.defaultExpectation.expectationOrigins.origin, *m.DeleteSongMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteSong != nil && afterDeleteSongCounter < 1 {
		m.t.Errorf("Expected call to PlaylistServiceMock.DeleteSong at\n%s", m.funcDeleteSongOrigin)
	}

	if !m.DeleteSongMock.invocationsDone() && afterDeleteSongCounter > 0 {
		m.t.Errorf("Expected %d calls to PlaylistServiceMock.DeleteSong at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteSongMock.expectedInvocations), m.DeleteSongMock.expectedInvocationsOrigin, afterDeleteSongCounter)
	}
}

type mPlaylistServiceMockNextSong struct {
	optional           bool
	mock               *PlaylistServiceMock
	defaultExpectation *PlaylistServiceMockNextSongExpectation
	expectations       []*PlaylistServiceMockNextSongExpectation

	callArgs []*PlaylistServiceMockNextSongParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PlaylistServiceMockNextSongExpectation specifies expectation struct of the PlaylistService.NextSong
type PlaylistServiceMockNextSongExpectation struct {
	mock               *PlaylistServiceMock
	params             *PlaylistServiceMockNextSongParams
	paramPtrs          *PlaylistServiceMockNextSongParamPtrs
	expectationOrigins PlaylistServiceMockNextSongExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// PlaylistServiceMockNextSongParams contains parameters of the PlaylistService.NextSong
type PlaylistServiceMockNextSongParams struct {
	ctx   context.Context
	login string
}

// PlaylistServiceMockNextSongParamPtrs contains pointers to parameters of the PlaylistService.NextSong
type PlaylistServiceMockNextSongParamPtrs struct {
	ctx   *context.Context
	login *string
}

// PlaylistServiceMockNextSongOrigins contains origins of expectations of the PlaylistService.NextSong
type PlaylistServiceMockNextSongExpectationOrigins struct {
	origin      string
	originCtx   string
	originLogin string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmNextSong *mPlaylistServiceMockNextSong) Optional() *mPlaylistServiceMockNextSong {
	mmNextSong.optional = true
	return mmNextSong
}

// Expect sets up expected params for PlaylistService.NextSong
func (mmNextSong *mPlaylistServiceMockNextSong) Expect(ctx context.Context, login string) *mPlaylistServiceMockNextSong {
	if mmNextSong.mock.funcNextSong != nil {
		mmNextSong.mock.t.Fatalf("PlaylistServiceMock.NextSong mock is already set by Set")
	}

	if mmNextSong.defaultExpectation == nil {
		mmNextSong.defaultExpectation = &PlaylistServiceMockNextSongExpectation{}
	}

	if mmNextSong.defaultExpectation.paramPtrs != nil {
		mmNextSong.mock.t.Fatalf("PlaylistServiceMock.NextSong mock is already set by ExpectParams functions")
	}

	mmNextSong.defaultExpectation.params = &PlaylistServiceMockNextSongParams{ctx, login}
	mmNextSong.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmNextSong.expectations {
		if minimock.Equal(e.params, mmNextSong.defaultExpectation.params) {
			mmNextSong.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNextSong.defaultExpectation.params)
		}
	}

	return mmNextSong
}

// ExpectCtxParam1 sets up expected param ctx for PlaylistService.NextSong
func (mmNextSong *mPlaylistServiceMockNextSong) ExpectCtxParam1(ctx context.Context) *mPlaylistServiceMockNextSong {
	if mmNextSong.mock.funcNextSong != nil {
		mmNextSong.mock.t.Fatalf("PlaylistServiceMock.NextSong mock is already set by Set")
	}

	if mmNextSong.defaultExpectation == nil {
		mmNextSong.defaultExpectation = &PlaylistServiceMockNextSongExpectation{}
	}

	if mmNextSong.defaultExpectation.params != nil {
		mmNextSong.mock.t.Fatalf("PlaylistServiceMock.NextSong mock is already set by Expect")
	}

	if mmNextSong.defaultExpectation.paramPtrs == nil {
		mmNextSong.defaultExpectation.paramPtrs = &PlaylistServiceMockNextSongParamPtrs{}
	}
	mmNextSong.defaultExpectation.paramPtrs.ctx = &ctx
	mmNextSong.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmNextSong
}

// ExpectLoginParam2 sets up expected param login for PlaylistService.NextSong
func (mmNextSong *mPlaylistServiceMockNextSong) ExpectLoginParam2(login string) *mPlaylistServiceMockNextSong {
	if mmNextSong.mock.funcNextSong != nil {
		mmNextSong.mock.t.Fatalf("PlaylistServiceMock.NextSong mock is already set by Set")
	}

	if mmNextSong.defaultExpectation == nil {
		mmNextSong.defaultExpectation = &PlaylistServiceMockNextSongExpectation{}
	}

	if mmNextSong.defaultExpectation.params != nil {
		mmNextSong.mock.t.Fatalf("PlaylistServiceMock.NextSong mock is already set by Expect")
	}

	if mmNextSong.defaultExpectation.paramPtrs == nil {
		mmNextSong.defaultExpectation.paramPtrs = &PlaylistServiceMockNextSongParamPtrs{}
	}
	mmNextSong.defaultExpectation.paramPtrs.login = &login
	mmNextSong.defaultExpectation.expectationOrigins.originLogin = minimock.CallerInfo(1)

	return mmNextSong
}

// Inspect accepts an inspector function that has same arguments as the PlaylistService.NextSong
func (mmNextSong *mPlaylistServiceMockNextSong) Inspect(f func(ctx context.Context, login string)) *mPlaylistServiceMockNextSong {
	if mmNextSong.mock.inspectFuncNextSong != nil {
		mmNextSong.mock.t.Fatalf("Inspect function is already set for PlaylistServiceMock.NextSong")
	}

	mmNextSong.mock.inspectFuncNextSong = f

	return mmNextSong
}

// Return sets up results that will be returned by PlaylistService.NextSong
func (mmNextSong *mPlaylistServiceMockNextSong) Return() *PlaylistServiceMock {
	if mmNextSong.mock.funcNextSong != nil {
		mmNextSong.mock.t.Fatalf("PlaylistServiceMock.NextSong mock is already set by Set")
	}

	if mmNextSong.defaultExpectation == nil {
		mmNextSong.defaultExpectation = &PlaylistServiceMockNextSongExpectation{mock: mmNextSong.mock}
	}

	mmNextSong.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmNextSong.mock
}

// Set uses given function f to mock the PlaylistService.NextSong method
func (mmNextSong *mPlaylistServiceMockNextSong) Set(f func(ctx context.Context, login string)) *PlaylistServiceMock {
	if mmNextSong.defaultExpectation != nil {
		mmNextSong.mock.t.Fatalf("Default expectation is already set for the PlaylistService.NextSong method")
	}

	if len(mmNextSong.expectations) > 0 {
		mmNextSong.mock.t.Fatalf("Some expectations are already set for the PlaylistService.NextSong method")
	}

	mmNextSong.mock.funcNextSong = f
	mmNextSong.mock.funcNextSongOrigin = minimock.CallerInfo(1)
	return mmNextSong.mock
}

// Times sets number of times PlaylistService.NextSong should be invoked
func (mmNextSong *mPlaylistServiceMockNextSong) Times(n uint64) *mPlaylistServiceMockNextSong {
	if n == 0 {
		mmNextSong.mock.t.Fatalf("Times of PlaylistServiceMock.NextSong mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmNextSong.expectedInvocations, n)
	mmNextSong.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmNextSong
}

func (mmNextSong *mPlaylistServiceMockNextSong) invocationsDone() bool {
	if len(mmNextSong.expectations) == 0 && mmNextSong.defaultExpectation == nil && mmNextSong.mock.funcNextSong == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmNextSong.mock.afterNextSongCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmNextSong.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// NextSong implements mm_playlist.PlaylistService
func (mmNextSong *PlaylistServiceMock) NextSong(ctx context.Context, login string) {
	mm_atomic.AddUint64(&mmNextSong.beforeNextSongCounter, 1)
	defer mm_atomic.AddUint64(&mmNextSong.afterNextSongCounter, 1)

	mmNextSong.t.Helper()

	if mmNextSong.inspectFuncNextSong != nil {
		mmNextSong.inspectFuncNextSong(ctx, login)
	}

	mm_params := PlaylistServiceMockNextSongParams{ctx, login}

	// Record call args
	mmNextSong.NextSongMock.mutex.Lock()
	mmNextSong.NextSongMock.callArgs = append(mmNextSong.NextSongMock.callArgs, &mm_params)
	mmNextSong.NextSongMock.mutex.Unlock()

	for _, e := range mmNextSong.NextSongMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmNextSong.NextSongMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNextSong.NextSongMock.defaultExpectation.Counter, 1)
		mm_want := mmNextSong.NextSongMock.defaultExpectation.params
		mm_want_ptrs := mmNextSong.NextSongMock.defaultExpectation.paramPtrs

		mm_got := PlaylistServiceMockNextSongParams{ctx, login}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmNextSong.t.Errorf("PlaylistServiceMock.NextSong got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmNextSong.NextSongMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.login != nil && !minimock.Equal(*mm_want_ptrs.login, mm_got.login) {
				mmNextSong.t.Errorf("PlaylistServiceMock.NextSong got unexpected parameter login, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmNextSong.NextSongMock.defaultExpectation.expectationOrigins.originLogin, *mm_want_ptrs.login, mm_got.login, minimock.Diff(*mm_want_ptrs.login, mm_got.login))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmNextSong.t.Errorf("PlaylistServiceMock.NextSong got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmNextSong.NextSongMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmNextSong.funcNextSong != nil {
		mmNextSong.funcNextSong(ctx, login)
		return
	}
	mmNextSong.t.Fatalf("Unexpected call to PlaylistServiceMock.NextSong. %v %v", ctx, login)

}

// NextSongAfterCounter returns a count of finished PlaylistServiceMock.NextSong invocations
func (mmNextSong *PlaylistServiceMock) NextSongAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNextSong.afterNextSongCounter)
}

// NextSongBeforeCounter returns a count of PlaylistServiceMock.NextSong invocations
func (mmNextSong *PlaylistServiceMock) NextSongBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNextSong.beforeNextSongCounter)
}

// Calls returns a list of arguments used in each call to PlaylistServiceMock.NextSong.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNextSong *mPlaylistServiceMockNextSong) Calls() []*PlaylistServiceMockNextSongParams {
	mmNextSong.mutex.RLock()

	argCopy := make([]*PlaylistServiceMockNextSongParams, len(mmNextSong.callArgs))
	copy(argCopy, mmNextSong.callArgs)

	mmNextSong.mutex.RUnlock()

	return argCopy
}

// MinimockNextSongDone returns true if the count of the NextSong invocations corresponds
// the number of defined expectations
func (m *PlaylistServiceMock) MinimockNextSongDone() bool {
	if m.NextSongMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.NextSongMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.NextSongMock.invocationsDone()
}

// MinimockNextSongInspect logs each unmet expectation
func (m *PlaylistServiceMock) MinimockNextSongInspect() {
	for _, e := range m.NextSongMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PlaylistServiceMock.NextSong at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterNextSongCounter := mm_atomic.LoadUint64(&m.afterNextSongCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.NextSongMock.defaultExpectation != nil && afterNextSongCounter < 1 {
		if m.NextSongMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PlaylistServiceMock.NextSong at\n%s", m.NextSongMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PlaylistServiceMock.NextSong at\n%s with params: %#v", m.NextSongMock.defaultExpectation.expectationOrigins.origin, *m.NextSongMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNextSong != nil && afterNextSongCounter < 1 {
		m.t.Errorf("Expected call to PlaylistServiceMock.NextSong at\n%s", m.funcNextSongOrigin)
	}

	if !m.NextSongMock.invocationsDone() && afterNextSongCounter > 0 {
		m.t.Errorf("Expected %d calls to PlaylistServiceMock.NextSong at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.NextSongMock.expectedInvocations), m.NextSongMock.expectedInvocationsOrigin, afterNextSongCounter)
	}
}

type mPlaylistServiceMockPauseSong struct {
	optional           bool
	mock               *PlaylistServiceMock
	defaultExpectation *PlaylistServiceMockPauseSongExpectation
	expectations       []*PlaylistServiceMockPauseSongExpectation

	callArgs []*PlaylistServiceMockPauseSongParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PlaylistServiceMockPauseSongExpectation specifies expectation struct of the PlaylistService.PauseSong
type PlaylistServiceMockPauseSongExpectation struct {
	mock               *PlaylistServiceMock
	params             *PlaylistServiceMockPauseSongParams
	paramPtrs          *PlaylistServiceMockPauseSongParamPtrs
	expectationOrigins PlaylistServiceMockPauseSongExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// PlaylistServiceMockPauseSongParams contains parameters of the PlaylistService.PauseSong
type PlaylistServiceMockPauseSongParams struct {
	ctx   context.Context
	login string
}

// PlaylistServiceMockPauseSongParamPtrs contains pointers to parameters of the PlaylistService.PauseSong
type PlaylistServiceMockPauseSongParamPtrs struct {
	ctx   *context.Context
	login *string
}

// PlaylistServiceMockPauseSongOrigins contains origins of expectations of the PlaylistService.PauseSong
type PlaylistServiceMockPauseSongExpectationOrigins struct {
	origin      string
	originCtx   string
	originLogin string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPauseSong *mPlaylistServiceMockPauseSong) Optional() *mPlaylistServiceMockPauseSong {
	mmPauseSong.optional = true
	return mmPauseSong
}

// Expect sets up expected params for PlaylistService.PauseSong
func (mmPauseSong *mPlaylistServiceMockPauseSong) Expect(ctx context.Context, login string) *mPlaylistServiceMockPauseSong {
	if mmPauseSong.mock.funcPauseSong != nil {
		mmPauseSong.mock.t.Fatalf("PlaylistServiceMock.PauseSong mock is already set by Set")
	}

	if mmPauseSong.defaultExpectation == nil {
		mmPauseSong.defaultExpectation = &PlaylistServiceMockPauseSongExpectation{}
	}

	if mmPauseSong.defaultExpectation.paramPtrs != nil {
		mmPauseSong.mock.t.Fatalf("PlaylistServiceMock.PauseSong mock is already set by ExpectParams functions")
	}

	mmPauseSong.defaultExpectation.params = &PlaylistServiceMockPauseSongParams{ctx, login}
	mmPauseSong.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPauseSong.expectations {
		if minimock.Equal(e.params, mmPauseSong.defaultExpectation.params) {
			mmPauseSong.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPauseSong.defaultExpectation.params)
		}
	}

	return mmPauseSong
}

// ExpectCtxParam1 sets up expected param ctx for PlaylistService.PauseSong
func (mmPauseSong *mPlaylistServiceMockPauseSong) ExpectCtxParam1(ctx context.Context) *mPlaylistServiceMockPauseSong {
	if mmPauseSong.mock.funcPauseSong != nil {
		mmPauseSong.mock.t.Fatalf("PlaylistServiceMock.PauseSong mock is already set by Set")
	}

	if mmPauseSong.defaultExpectation == nil {
		mmPauseSong.defaultExpectation = &PlaylistServiceMockPauseSongExpectation{}
	}

	if mmPauseSong.defaultExpectation.params != nil {
		mmPauseSong.mock.t.Fatalf("PlaylistServiceMock.PauseSong mock is already set by Expect")
	}

	if mmPauseSong.defaultExpectation.paramPtrs == nil {
		mmPauseSong.defaultExpectation.paramPtrs = &PlaylistServiceMockPauseSongParamPtrs{}
	}
	mmPauseSong.defaultExpectation.paramPtrs.ctx = &ctx
	mmPauseSong.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPauseSong
}

// ExpectLoginParam2 sets up expected param login for PlaylistService.PauseSong
func (mmPauseSong *mPlaylistServiceMockPauseSong) ExpectLoginParam2(login string) *mPlaylistServiceMockPauseSong {
	if mmPauseSong.mock.funcPauseSong != nil {
		mmPauseSong.mock.t.Fatalf("PlaylistServiceMock.PauseSong mock is already set by Set")
	}

	if mmPauseSong.defaultExpectation == nil {
		mmPauseSong.defaultExpectation = &PlaylistServiceMockPauseSongExpectation{}
	}

	if mmPauseSong.defaultExpectation.params != nil {
		mmPauseSong.mock.t.Fatalf("PlaylistServiceMock.PauseSong mock is already set by Expect")
	}

	if mmPauseSong.defaultExpectation.paramPtrs == nil {
		mmPauseSong.defaultExpectation.paramPtrs = &PlaylistServiceMockPauseSongParamPtrs{}
	}
	mmPauseSong.defaultExpectation.paramPtrs.login = &login
	mmPauseSong.defaultExpectation.expectationOrigins.originLogin = minimock.CallerInfo(1)

	return mmPauseSong
}

// Inspect accepts an inspector function that has same arguments as the PlaylistService.PauseSong
func (mmPauseSong *mPlaylistServiceMockPauseSong) Inspect(f func(ctx context.Context, login string)) *mPlaylistServiceMockPauseSong {
	if mmPauseSong.mock.inspectFuncPauseSong != nil {
		mmPauseSong.mock.t.Fatalf("Inspect function is already set for PlaylistServiceMock.PauseSong")
	}

	mmPauseSong.mock.inspectFuncPauseSong = f

	return mmPauseSong
}

// Return sets up results that will be returned by PlaylistService.PauseSong
func (mmPauseSong *mPlaylistServiceMockPauseSong) Return() *PlaylistServiceMock {
	if mmPauseSong.mock.funcPauseSong != nil {
		mmPauseSong.mock.t.Fatalf("PlaylistServiceMock.PauseSong mock is already set by Set")
	}

	if mmPauseSong.defaultExpectation == nil {
		mmPauseSong.defaultExpectation = &PlaylistServiceMockPauseSongExpectation{mock: mmPauseSong.mock}
	}

	mmPauseSong.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPauseSong.mock
}

// Set uses given function f to mock the PlaylistService.PauseSong method
func (mmPauseSong *mPlaylistServiceMockPauseSong) Set(f func(ctx context.Context, login string)) *PlaylistServiceMock {
	if mmPauseSong.defaultExpectation != nil {
		mmPauseSong.mock.t.Fatalf("Default expectation is already set for the PlaylistService.PauseSong method")
	}

	if len(mmPauseSong.expectations) > 0 {
		mmPauseSong.mock.t.Fatalf("Some expectations are already set for the PlaylistService.PauseSong method")
	}

	mmPauseSong.mock.funcPauseSong = f
	mmPauseSong.mock.funcPauseSongOrigin = minimock.CallerInfo(1)
	return mmPauseSong.mock
}

// Times sets number of times PlaylistService.PauseSong should be invoked
func (mmPauseSong *mPlaylistServiceMockPauseSong) Times(n uint64) *mPlaylistServiceMockPauseSong {
	if n == 0 {
		mmPauseSong.mock.t.Fatalf("Times of PlaylistServiceMock.PauseSong mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPauseSong.expectedInvocations, n)
	mmPauseSong.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPauseSong
}

func (mmPauseSong *mPlaylistServiceMockPauseSong) invocationsDone() bool {
	if len(mmPauseSong.expectations) == 0 && mmPauseSong.defaultExpectation == nil && mmPauseSong.mock.funcPauseSong == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPauseSong.mock.afterPauseSongCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPauseSong.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// PauseSong implements mm_playlist.PlaylistService
func (mmPauseSong *PlaylistServiceMock) PauseSong(ctx context.Context, login string) {
	mm_atomic.AddUint64(&mmPauseSong.beforePauseSongCounter, 1)
	defer mm_atomic.AddUint64(&mmPauseSong.afterPauseSongCounter, 1)

	mmPauseSong.t.Helper()

	if mmPauseSong.inspectFuncPauseSong != nil {
		mmPauseSong.inspectFuncPauseSong(ctx, login)
	}

	mm_params := PlaylistServiceMockPauseSongParams{ctx, login}

	// Record call args
	mmPauseSong.PauseSongMock.mutex.Lock()
	mmPauseSong.PauseSongMock.callArgs = append(mmPauseSong.PauseSongMock.callArgs, &mm_params)
	mmPauseSong.PauseSongMock.mutex.Unlock()

	for _, e := range mmPauseSong.PauseSongMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPauseSong.PauseSongMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPauseSong.PauseSongMock.defaultExpectation.Counter, 1)
		mm_want := mmPauseSong.PauseSongMock.defaultExpectation.params
		mm_want_ptrs := mmPauseSong.PauseSongMock.defaultExpectation.paramPtrs

		mm_got := PlaylistServiceMockPauseSongParams{ctx, login}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPauseSong.t.Errorf("PlaylistServiceMock.PauseSong got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPauseSong.PauseSongMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.login != nil && !minimock.Equal(*mm_want_ptrs.login, mm_got.login) {
				mmPauseSong.t.Errorf("PlaylistServiceMock.PauseSong got unexpected parameter login, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPauseSong.PauseSongMock.defaultExpectation.expectationOrigins.originLogin, *mm_want_ptrs.login, mm_got.login, minimock.Diff(*mm_want_ptrs.login, mm_got.login))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPauseSong.t.Errorf("PlaylistServiceMock.PauseSong got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPauseSong.PauseSongMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmPauseSong.funcPauseSong != nil {
		mmPauseSong.funcPauseSong(ctx, login)
		return
	}
	mmPauseSong.t.Fatalf("Unexpected call to PlaylistServiceMock.PauseSong. %v %v", ctx, login)

}

// PauseSongAfterCounter returns a count of finished PlaylistServiceMock.PauseSong invocations
func (mmPauseSong *PlaylistServiceMock) PauseSongAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPauseSong.afterPauseSongCounter)
}

// PauseSongBeforeCounter returns a count of PlaylistServiceMock.PauseSong invocations
func (mmPauseSong *PlaylistServiceMock) PauseSongBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPauseSong.beforePauseSongCounter)
}

// Calls returns a list of arguments used in each call to PlaylistServiceMock.PauseSong.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPauseSong *mPlaylistServiceMockPauseSong) Calls() []*PlaylistServiceMockPauseSongParams {
	mmPauseSong.mutex.RLock()

	argCopy := make([]*PlaylistServiceMockPauseSongParams, len(mmPauseSong.callArgs))
	copy(argCopy, mmPauseSong.callArgs)

	mmPauseSong.mutex.RUnlock()

	return argCopy
}

// MinimockPauseSongDone returns true if the count of the PauseSong invocations corresponds
// the number of defined expectations
func (m *PlaylistServiceMock) MinimockPauseSongDone() bool {
	if m.PauseSongMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PauseSongMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PauseSongMock.invocationsDone()
}

// MinimockPauseSongInspect logs each unmet expectation
func (m *PlaylistServiceMock) MinimockPauseSongInspect() {
	for _, e := range m.PauseSongMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PlaylistServiceMock.PauseSong at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPauseSongCounter := mm_atomic.LoadUint64(&m.afterPauseSongCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PauseSongMock.defaultExpectation != nil && afterPauseSongCounter < 1 {
		if m.PauseSongMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PlaylistServiceMock.PauseSong at\n%s", m.PauseSongMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PlaylistServiceMock.PauseSong at\n%s with params: %#v", m.PauseSongMock.defaultExpectation.expectationOrigins.origin, *m.PauseSongMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPauseSong != nil && afterPauseSongCounter < 1 {
		m.t.Errorf("Expected call to PlaylistServiceMock.PauseSong at\n%s", m.funcPauseSongOrigin)
	}

	if !m.PauseSongMock.invocationsDone() && afterPauseSongCounter > 0 {
		m.t.Errorf("Expected %d calls to PlaylistServiceMock.PauseSong at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PauseSongMock.expectedInvocations), m.PauseSongMock.expectedInvocationsOrigin, afterPauseSongCounter)
	}
}

type mPlaylistServiceMockPlaySong struct {
	optional           bool
	mock               *PlaylistServiceMock
	defaultExpectation *PlaylistServiceMockPlaySongExpectation
	expectations       []*PlaylistServiceMockPlaySongExpectation

	callArgs []*PlaylistServiceMockPlaySongParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PlaylistServiceMockPlaySongExpectation specifies expectation struct of the PlaylistService.PlaySong
type PlaylistServiceMockPlaySongExpectation struct {
	mock               *PlaylistServiceMock
	params             *PlaylistServiceMockPlaySongParams
	paramPtrs          *PlaylistServiceMockPlaySongParamPtrs
	expectationOrigins PlaylistServiceMockPlaySongExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// PlaylistServiceMockPlaySongParams contains parameters of the PlaylistService.PlaySong
type PlaylistServiceMockPlaySongParams struct {
	ctx   context.Context
	login string
}

// PlaylistServiceMockPlaySongParamPtrs contains pointers to parameters of the PlaylistService.PlaySong
type PlaylistServiceMockPlaySongParamPtrs struct {
	ctx   *context.Context
	login *string
}

// PlaylistServiceMockPlaySongOrigins contains origins of expectations of the PlaylistService.PlaySong
type PlaylistServiceMockPlaySongExpectationOrigins struct {
	origin      string
	originCtx   string
	originLogin string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPlaySong *mPlaylistServiceMockPlaySong) Optional() *mPlaylistServiceMockPlaySong {
	mmPlaySong.optional = true
	return mmPlaySong
}

// Expect sets up expected params for PlaylistService.PlaySong
func (mmPlaySong *mPlaylistServiceMockPlaySong) Expect(ctx context.Context, login string) *mPlaylistServiceMockPlaySong {
	if mmPlaySong.mock.funcPlaySong != nil {
		mmPlaySong.mock.t.Fatalf("PlaylistServiceMock.PlaySong mock is already set by Set")
	}

	if mmPlaySong.defaultExpectation == nil {
		mmPlaySong.defaultExpectation = &PlaylistServiceMockPlaySongExpectation{}
	}

	if mmPlaySong.defaultExpectation.paramPtrs != nil {
		mmPlaySong.mock.t.Fatalf("PlaylistServiceMock.PlaySong mock is already set by ExpectParams functions")
	}

	mmPlaySong.defaultExpectation.params = &PlaylistServiceMockPlaySongParams{ctx, login}
	mmPlaySong.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPlaySong.expectations {
		if minimock.Equal(e.params, mmPlaySong.defaultExpectation.params) {
			mmPlaySong.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPlaySong.defaultExpectation.params)
		}
	}

	return mmPlaySong
}

// ExpectCtxParam1 sets up expected param ctx for PlaylistService.PlaySong
func (mmPlaySong *mPlaylistServiceMockPlaySong) ExpectCtxParam1(ctx context.Context) *mPlaylistServiceMockPlaySong {
	if mmPlaySong.mock.funcPlaySong != nil {
		mmPlaySong.mock.t.Fatalf("PlaylistServiceMock.PlaySong mock is already set by Set")
	}

	if mmPlaySong.defaultExpectation == nil {
		mmPlaySong.defaultExpectation = &PlaylistServiceMockPlaySongExpectation{}
	}

	if mmPlaySong.defaultExpectation.params != nil {
		mmPlaySong.mock.t.Fatalf("PlaylistServiceMock.PlaySong mock is already set by Expect")
	}

	if mmPlaySong.defaultExpectation.paramPtrs == nil {
		mmPlaySong.defaultExpectation.paramPtrs = &PlaylistServiceMockPlaySongParamPtrs{}
	}
	mmPlaySong.defaultExpectation.paramPtrs.ctx = &ctx
	mmPlaySong.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPlaySong
}

// ExpectLoginParam2 sets up expected param login for PlaylistService.PlaySong
func (mmPlaySong *mPlaylistServiceMockPlaySong) ExpectLoginParam2(login string) *mPlaylistServiceMockPlaySong {
	if mmPlaySong.mock.funcPlaySong != nil {
		mmPlaySong.mock.t.Fatalf("PlaylistServiceMock.PlaySong mock is already set by Set")
	}

	if mmPlaySong.defaultExpectation == nil {
		mmPlaySong.defaultExpectation = &PlaylistServiceMockPlaySongExpectation{}
	}

	if mmPlaySong.defaultExpectation.params != nil {
		mmPlaySong.mock.t.Fatalf("PlaylistServiceMock.PlaySong mock is already set by Expect")
	}

	if mmPlaySong.defaultExpectation.paramPtrs == nil {
		mmPlaySong.defaultExpectation.paramPtrs = &PlaylistServiceMockPlaySongParamPtrs{}
	}
	mmPlaySong.defaultExpectation.paramPtrs.login = &login
	mmPlaySong.defaultExpectation.expectationOrigins.originLogin = minimock.CallerInfo(1)

	return mmPlaySong
}

// Inspect accepts an inspector function that has same arguments as the PlaylistService.PlaySong
func (mmPlaySong *mPlaylistServiceMockPlaySong) Inspect(f func(ctx context.Context, login string)) *mPlaylistServiceMockPlaySong {
	if mmPlaySong.mock.inspectFuncPlaySong != nil {
		mmPlaySong.mock.t.Fatalf("Inspect function is already set for PlaylistServiceMock.PlaySong")
	}

	mmPlaySong.mock.inspectFuncPlaySong = f

	return mmPlaySong
}

// Return sets up results that will be returned by PlaylistService.PlaySong
func (mmPlaySong *mPlaylistServiceMockPlaySong) Return() *PlaylistServiceMock {
	if mmPlaySong.mock.funcPlaySong != nil {
		mmPlaySong.mock.t.Fatalf("PlaylistServiceMock.PlaySong mock is already set by Set")
	}

	if mmPlaySong.defaultExpectation == nil {
		mmPlaySong.defaultExpectation = &PlaylistServiceMockPlaySongExpectation{mock: mmPlaySong.mock}
	}

	mmPlaySong.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPlaySong.mock
}

// Set uses given function f to mock the PlaylistService.PlaySong method
func (mmPlaySong *mPlaylistServiceMockPlaySong) Set(f func(ctx context.Context, login string)) *PlaylistServiceMock {
	if mmPlaySong.defaultExpectation != nil {
		mmPlaySong.mock.t.Fatalf("Default expectation is already set for the PlaylistService.PlaySong method")
	}

	if len(mmPlaySong.expectations) > 0 {
		mmPlaySong.mock.t.Fatalf("Some expectations are already set for the PlaylistService.PlaySong method")
	}

	mmPlaySong.mock.funcPlaySong = f
	mmPlaySong.mock.funcPlaySongOrigin = minimock.CallerInfo(1)
	return mmPlaySong.mock
}

// Times sets number of times PlaylistService.PlaySong should be invoked
func (mmPlaySong *mPlaylistServiceMockPlaySong) Times(n uint64) *mPlaylistServiceMockPlaySong {
	if n == 0 {
		mmPlaySong.mock.t.Fatalf("Times of PlaylistServiceMock.PlaySong mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPlaySong.expectedInvocations, n)
	mmPlaySong.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPlaySong
}

func (mmPlaySong *mPlaylistServiceMockPlaySong) invocationsDone() bool {
	if len(mmPlaySong.expectations) == 0 && mmPlaySong.defaultExpectation == nil && mmPlaySong.mock.funcPlaySong == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPlaySong.mock.afterPlaySongCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPlaySong.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// PlaySong implements mm_playlist.PlaylistService
func (mmPlaySong *PlaylistServiceMock) PlaySong(ctx context.Context, login string) {
	mm_atomic.AddUint64(&mmPlaySong.beforePlaySongCounter, 1)
	defer mm_atomic.AddUint64(&mmPlaySong.afterPlaySongCounter, 1)

	mmPlaySong.t.Helper()

	if mmPlaySong.inspectFuncPlaySong != nil {
		mmPlaySong.inspectFuncPlaySong(ctx, login)
	}

	mm_params := PlaylistServiceMockPlaySongParams{ctx, login}

	// Record call args
	mmPlaySong.PlaySongMock.mutex.Lock()
	mmPlaySong.PlaySongMock.callArgs = append(mmPlaySong.PlaySongMock.callArgs, &mm_params)
	mmPlaySong.PlaySongMock.mutex.Unlock()

	for _, e := range mmPlaySong.PlaySongMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPlaySong.PlaySongMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPlaySong.PlaySongMock.defaultExpectation.Counter, 1)
		mm_want := mmPlaySong.PlaySongMock.defaultExpectation.params
		mm_want_ptrs := mmPlaySong.PlaySongMock.defaultExpectation.paramPtrs

		mm_got := PlaylistServiceMockPlaySongParams{ctx, login}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPlaySong.t.Errorf("PlaylistServiceMock.PlaySong got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPlaySong.PlaySongMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.login != nil && !minimock.Equal(*mm_want_ptrs.login, mm_got.login) {
				mmPlaySong.t.Errorf("PlaylistServiceMock.PlaySong got unexpected parameter login, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPlaySong.PlaySongMock.defaultExpectation.expectationOrigins.originLogin, *mm_want_ptrs.login, mm_got.login, minimock.Diff(*mm_want_ptrs.login, mm_got.login))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPlaySong.t.Errorf("PlaylistServiceMock.PlaySong got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPlaySong.PlaySongMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmPlaySong.funcPlaySong != nil {
		mmPlaySong.funcPlaySong(ctx, login)
		return
	}
	mmPlaySong.t.Fatalf("Unexpected call to PlaylistServiceMock.PlaySong. %v %v", ctx, login)

}

// PlaySongAfterCounter returns a count of finished PlaylistServiceMock.PlaySong invocations
func (mmPlaySong *PlaylistServiceMock) PlaySongAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPlaySong.afterPlaySongCounter)
}

// PlaySongBeforeCounter returns a count of PlaylistServiceMock.PlaySong invocations
func (mmPlaySong *PlaylistServiceMock) PlaySongBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPlaySong.beforePlaySongCounter)
}

// Calls returns a list of arguments used in each call to PlaylistServiceMock.PlaySong.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPlaySong *mPlaylistServiceMockPlaySong) Calls() []*PlaylistServiceMockPlaySongParams {
	mmPlaySong.mutex.RLock()

	argCopy := make([]*PlaylistServiceMockPlaySongParams, len(mmPlaySong.callArgs))
	copy(argCopy, mmPlaySong.callArgs)

	mmPlaySong.mutex.RUnlock()

	return argCopy
}

// MinimockPlaySongDone returns true if the count of the PlaySong invocations corresponds
// the number of defined expectations
func (m *PlaylistServiceMock) MinimockPlaySongDone() bool {
	if m.PlaySongMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PlaySongMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PlaySongMock.invocationsDone()
}

// MinimockPlaySongInspect logs each unmet expectation
func (m *PlaylistServiceMock) MinimockPlaySongInspect() {
	for _, e := range m.PlaySongMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PlaylistServiceMock.PlaySong at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPlaySongCounter := mm_atomic.LoadUint64(&m.afterPlaySongCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PlaySongMock.defaultExpectation != nil && afterPlaySongCounter < 1 {
		if m.PlaySongMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PlaylistServiceMock.PlaySong at\n%s", m.PlaySongMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PlaylistServiceMock.PlaySong at\n%s with params: %#v", m.PlaySongMock.defaultExpectation.expectationOrigins.origin, *m.PlaySongMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPlaySong != nil && afterPlaySongCounter < 1 {
		m.t.Errorf("Expected call to PlaylistServiceMock.PlaySong at\n%s", m.funcPlaySongOrigin)
	}

	if !m.PlaySongMock.invocationsDone() && afterPlaySongCounter > 0 {
		m.t.Errorf("Expected %d calls to PlaylistServiceMock.PlaySong at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PlaySongMock.expectedInvocations), m.PlaySongMock.expectedInvocationsOrigin, afterPlaySongCounter)
	}
}

type mPlaylistServiceMockPrevSong struct {
	optional           bool
	mock               *PlaylistServiceMock
	defaultExpectation *PlaylistServiceMockPrevSongExpectation
	expectations       []*PlaylistServiceMockPrevSongExpectation

	callArgs []*PlaylistServiceMockPrevSongParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PlaylistServiceMockPrevSongExpectation specifies expectation struct of the PlaylistService.PrevSong
type PlaylistServiceMockPrevSongExpectation struct {
	mock               *PlaylistServiceMock
	params             *PlaylistServiceMockPrevSongParams
	paramPtrs          *PlaylistServiceMockPrevSongParamPtrs
	expectationOrigins PlaylistServiceMockPrevSongExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// PlaylistServiceMockPrevSongParams contains parameters of the PlaylistService.PrevSong
type PlaylistServiceMockPrevSongParams struct {
	ctx   context.Context
	login string
}

// PlaylistServiceMockPrevSongParamPtrs contains pointers to parameters of the PlaylistService.PrevSong
type PlaylistServiceMockPrevSongParamPtrs struct {
	ctx   *context.Context
	login *string
}

// PlaylistServiceMockPrevSongOrigins contains origins of expectations of the PlaylistService.PrevSong
type PlaylistServiceMockPrevSongExpectationOrigins struct {
	origin      string
	originCtx   string
	originLogin string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPrevSong *mPlaylistServiceMockPrevSong) Optional() *mPlaylistServiceMockPrevSong {
	mmPrevSong.optional = true
	return mmPrevSong
}

// Expect sets up expected params for PlaylistService.PrevSong
func (mmPrevSong *mPlaylistServiceMockPrevSong) Expect(ctx context.Context, login string) *mPlaylistServiceMockPrevSong {
	if mmPrevSong.mock.funcPrevSong != nil {
		mmPrevSong.mock.t.Fatalf("PlaylistServiceMock.PrevSong mock is already set by Set")
	}

	if mmPrevSong.defaultExpectation == nil {
		mmPrevSong.defaultExpectation = &PlaylistServiceMockPrevSongExpectation{}
	}

	if mmPrevSong.defaultExpectation.paramPtrs != nil {
		mmPrevSong.mock.t.Fatalf("PlaylistServiceMock.PrevSong mock is already set by ExpectParams functions")
	}

	mmPrevSong.defaultExpectation.params = &PlaylistServiceMockPrevSongParams{ctx, login}
	mmPrevSong.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPrevSong.expectations {
		if minimock.Equal(e.params, mmPrevSong.defaultExpectation.params) {
			mmPrevSong.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrevSong.defaultExpectation.params)
		}
	}

	return mmPrevSong
}

// ExpectCtxParam1 sets up expected param ctx for PlaylistService.PrevSong
func (mmPrevSong *mPlaylistServiceMockPrevSong) ExpectCtxParam1(ctx context.Context) *mPlaylistServiceMockPrevSong {
	if mmPrevSong.mock.funcPrevSong != nil {
		mmPrevSong.mock.t.Fatalf("PlaylistServiceMock.PrevSong mock is already set by Set")
	}

	if mmPrevSong.defaultExpectation == nil {
		mmPrevSong.defaultExpectation = &PlaylistServiceMockPrevSongExpectation{}
	}

	if mmPrevSong.defaultExpectation.params != nil {
		mmPrevSong.mock.t.Fatalf("PlaylistServiceMock.PrevSong mock is already set by Expect")
	}

	if mmPrevSong.defaultExpectation.paramPtrs == nil {
		mmPrevSong.defaultExpectation.paramPtrs = &PlaylistServiceMockPrevSongParamPtrs{}
	}
	mmPrevSong.defaultExpectation.paramPtrs.ctx = &ctx
	mmPrevSong.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPrevSong
}

// ExpectLoginParam2 sets up expected param login for PlaylistService.PrevSong
func (mmPrevSong *mPlaylistServiceMockPrevSong) ExpectLoginParam2(login string) *mPlaylistServiceMockPrevSong {
	if mmPrevSong.mock.funcPrevSong != nil {
		mmPrevSong.mock.t.Fatalf("PlaylistServiceMock.PrevSong mock is already set by Set")
	}

	if mmPrevSong.defaultExpectation == nil {
		mmPrevSong.defaultExpectation = &PlaylistServiceMockPrevSongExpectation{}
	}

	if mmPrevSong.defaultExpectation.params != nil {
		mmPrevSong.mock.t.Fatalf("PlaylistServiceMock.PrevSong mock is already set by Expect")
	}

	if mmPrevSong.defaultExpectation.paramPtrs == nil {
		mmPrevSong.defaultExpectation.paramPtrs = &PlaylistServiceMockPrevSongParamPtrs{}
	}
	mmPrevSong.defaultExpectation.paramPtrs.login = &login
	mmPrevSong.defaultExpectation.expectationOrigins.originLogin = minimock.CallerInfo(1)

	return mmPrevSong
}

// Inspect accepts an inspector function that has same arguments as the PlaylistService.PrevSong
func (mmPrevSong *mPlaylistServiceMockPrevSong) Inspect(f func(ctx context.Context, login string)) *mPlaylistServiceMockPrevSong {
	if mmPrevSong.mock.inspectFuncPrevSong != nil {
		mmPrevSong.mock.t.Fatalf("Inspect function is already set for PlaylistServiceMock.PrevSong")
	}

	mmPrevSong.mock.inspectFuncPrevSong = f

	return mmPrevSong
}

// Return sets up results that will be returned by PlaylistService.PrevSong
func (mmPrevSong *mPlaylistServiceMockPrevSong) Return() *PlaylistServiceMock {
	if mmPrevSong.mock.funcPrevSong != nil {
		mmPrevSong.mock.t.Fatalf("PlaylistServiceMock.PrevSong mock is already set by Set")
	}

	if mmPrevSong.defaultExpectation == nil {
		mmPrevSong.defaultExpectation = &PlaylistServiceMockPrevSongExpectation{mock: mmPrevSong.mock}
	}

	mmPrevSong.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPrevSong.mock
}

// Set uses given function f to mock the PlaylistService.PrevSong method
func (mmPrevSong *mPlaylistServiceMockPrevSong) Set(f func(ctx context.Context, login string)) *PlaylistServiceMock {
	if mmPrevSong.defaultExpectation != nil {
		mmPrevSong.mock.t.Fatalf("Default expectation is already set for the PlaylistService.PrevSong method")
	}

	if len(mmPrevSong.expectations) > 0 {
		mmPrevSong.mock.t.Fatalf("Some expectations are already set for the PlaylistService.PrevSong method")
	}

	mmPrevSong.mock.funcPrevSong = f
	mmPrevSong.mock.funcPrevSongOrigin = minimock.CallerInfo(1)
	return mmPrevSong.mock
}

// Times sets number of times PlaylistService.PrevSong should be invoked
func (mmPrevSong *mPlaylistServiceMockPrevSong) Times(n uint64) *mPlaylistServiceMockPrevSong {
	if n == 0 {
		mmPrevSong.mock.t.Fatalf("Times of PlaylistServiceMock.PrevSong mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPrevSong.expectedInvocations, n)
	mmPrevSong.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPrevSong
}

func (mmPrevSong *mPlaylistServiceMockPrevSong) invocationsDone() bool {
	if len(mmPrevSong.expectations) == 0 && mmPrevSong.defaultExpectation == nil && mmPrevSong.mock.funcPrevSong == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPrevSong.mock.afterPrevSongCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPrevSong.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// PrevSong implements mm_playlist.PlaylistService
func (mmPrevSong *PlaylistServiceMock) PrevSong(ctx context.Context, login string) {
	mm_atomic.AddUint64(&mmPrevSong.beforePrevSongCounter, 1)
	defer mm_atomic.AddUint64(&mmPrevSong.afterPrevSongCounter, 1)

	mmPrevSong.t.Helper()

	if mmPrevSong.inspectFuncPrevSong != nil {
		mmPrevSong.inspectFuncPrevSong(ctx, login)
	}

	mm_params := PlaylistServiceMockPrevSongParams{ctx, login}

	// Record call args
	mmPrevSong.PrevSongMock.mutex.Lock()
	mmPrevSong.PrevSongMock.callArgs = append(mmPrevSong.PrevSongMock.callArgs, &mm_params)
	mmPrevSong.PrevSongMock.mutex.Unlock()

	for _, e := range mmPrevSong.PrevSongMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPrevSong.PrevSongMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrevSong.PrevSongMock.defaultExpectation.Counter, 1)
		mm_want := mmPrevSong.PrevSongMock.defaultExpectation.params
		mm_want_ptrs := mmPrevSong.PrevSongMock.defaultExpectation.paramPtrs

		mm_got := PlaylistServiceMockPrevSongParams{ctx, login}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPrevSong.t.Errorf("PlaylistServiceMock.PrevSong got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPrevSong.PrevSongMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.login != nil && !minimock.Equal(*mm_want_ptrs.login, mm_got.login) {
				mmPrevSong.t.Errorf("PlaylistServiceMock.PrevSong got unexpected parameter login, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPrevSong.PrevSongMock.defaultExpectation.expectationOrigins.originLogin, *mm_want_ptrs.login, mm_got.login, minimock.Diff(*mm_want_ptrs.login, mm_got.login))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPrevSong.t.Errorf("PlaylistServiceMock.PrevSong got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPrevSong.PrevSongMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmPrevSong.funcPrevSong != nil {
		mmPrevSong.funcPrevSong(ctx, login)
		return
	}
	mmPrevSong.t.Fatalf("Unexpected call to PlaylistServiceMock.PrevSong. %v %v", ctx, login)

}

// PrevSongAfterCounter returns a count of finished PlaylistServiceMock.PrevSong invocations
func (mmPrevSong *PlaylistServiceMock) PrevSongAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrevSong.afterPrevSongCounter)
}

// PrevSongBeforeCounter returns a count of PlaylistServiceMock.PrevSong invocations
func (mmPrevSong *PlaylistServiceMock) PrevSongBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrevSong.beforePrevSongCounter)
}

// Calls returns a list of arguments used in each call to PlaylistServiceMock.PrevSong.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrevSong *mPlaylistServiceMockPrevSong) Calls() []*PlaylistServiceMockPrevSongParams {
	mmPrevSong.mutex.RLock()

	argCopy := make([]*PlaylistServiceMockPrevSongParams, len(mmPrevSong.callArgs))
	copy(argCopy, mmPrevSong.callArgs)

	mmPrevSong.mutex.RUnlock()

	return argCopy
}

// MinimockPrevSongDone returns true if the count of the PrevSong invocations corresponds
// the number of defined expectations
func (m *PlaylistServiceMock) MinimockPrevSongDone() bool {
	if m.PrevSongMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PrevSongMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PrevSongMock.invocationsDone()
}

// MinimockPrevSongInspect logs each unmet expectation
func (m *PlaylistServiceMock) MinimockPrevSongInspect() {
	for _, e := range m.PrevSongMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PlaylistServiceMock.PrevSong at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPrevSongCounter := mm_atomic.LoadUint64(&m.afterPrevSongCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PrevSongMock.defaultExpectation != nil && afterPrevSongCounter < 1 {
		if m.PrevSongMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PlaylistServiceMock.PrevSong at\n%s", m.PrevSongMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PlaylistServiceMock.PrevSong at\n%s with params: %#v", m.PrevSongMock.defaultExpectation.expectationOrigins.origin, *m.PrevSongMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrevSong != nil && afterPrevSongCounter < 1 {
		m.t.Errorf("Expected call to PlaylistServiceMock.PrevSong at\n%s", m.funcPrevSongOrigin)
	}

	if !m.PrevSongMock.invocationsDone() && afterPrevSongCounter > 0 {
		m.t.Errorf("Expected %d calls to PlaylistServiceMock.PrevSong at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PrevSongMock.expectedInvocations), m.PrevSongMock.expectedInvocationsOrigin, afterPrevSongCounter)
	}
}

type mPlaylistServiceMockStartPlayback struct {
	optional           bool
	mock               *PlaylistServiceMock
	defaultExpectation *PlaylistServiceMockStartPlaybackExpectation
	expectations       []*PlaylistServiceMockStartPlaybackExpectation

	callArgs []*PlaylistServiceMockStartPlaybackParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PlaylistServiceMockStartPlaybackExpectation specifies expectation struct of the PlaylistService.StartPlayback
type PlaylistServiceMockStartPlaybackExpectation struct {
	mock               *PlaylistServiceMock
	params             *PlaylistServiceMockStartPlaybackParams
	paramPtrs          *PlaylistServiceMockStartPlaybackParamPtrs
	expectationOrigins PlaylistServiceMockStartPlaybackExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// PlaylistServiceMockStartPlaybackParams contains parameters of the PlaylistService.StartPlayback
type PlaylistServiceMockStartPlaybackParams struct {
	ctx   context.Context
	login string
	wg    *sync.WaitGroup
}

// PlaylistServiceMockStartPlaybackParamPtrs contains pointers to parameters of the PlaylistService.StartPlayback
type PlaylistServiceMockStartPlaybackParamPtrs struct {
	ctx   *context.Context
	login *string
	wg    **sync.WaitGroup
}

// PlaylistServiceMockStartPlaybackOrigins contains origins of expectations of the PlaylistService.StartPlayback
type PlaylistServiceMockStartPlaybackExpectationOrigins struct {
	origin      string
	originCtx   string
	originLogin string
	originWg    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStartPlayback *mPlaylistServiceMockStartPlayback) Optional() *mPlaylistServiceMockStartPlayback {
	mmStartPlayback.optional = true
	return mmStartPlayback
}

// Expect sets up expected params for PlaylistService.StartPlayback
func (mmStartPlayback *mPlaylistServiceMockStartPlayback) Expect(ctx context.Context, login string, wg *sync.WaitGroup) *mPlaylistServiceMockStartPlayback {
	if mmStartPlayback.mock.funcStartPlayback != nil {
		mmStartPlayback.mock.t.Fatalf("PlaylistServiceMock.StartPlayback mock is already set by Set")
	}

	if mmStartPlayback.defaultExpectation == nil {
		mmStartPlayback.defaultExpectation = &PlaylistServiceMockStartPlaybackExpectation{}
	}

	if mmStartPlayback.defaultExpectation.paramPtrs != nil {
		mmStartPlayback.mock.t.Fatalf("PlaylistServiceMock.StartPlayback mock is already set by ExpectParams functions")
	}

	mmStartPlayback.defaultExpectation.params = &PlaylistServiceMockStartPlaybackParams{ctx, login, wg}
	mmStartPlayback.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmStartPlayback.expectations {
		if minimock.Equal(e.params, mmStartPlayback.defaultExpectation.params) {
			mmStartPlayback.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStartPlayback.defaultExpectation.params)
		}
	}

	return mmStartPlayback
}

// ExpectCtxParam1 sets up expected param ctx for PlaylistService.StartPlayback
func (mmStartPlayback *mPlaylistServiceMockStartPlayback) ExpectCtxParam1(ctx context.Context) *mPlaylistServiceMockStartPlayback {
	if mmStartPlayback.mock.funcStartPlayback != nil {
		mmStartPlayback.mock.t.Fatalf("PlaylistServiceMock.StartPlayback mock is already set by Set")
	}

	if mmStartPlayback.defaultExpectation == nil {
		mmStartPlayback.defaultExpectation = &PlaylistServiceMockStartPlaybackExpectation{}
	}

	if mmStartPlayback.defaultExpectation.params != nil {
		mmStartPlayback.mock.t.Fatalf("PlaylistServiceMock.StartPlayback mock is already set by Expect")
	}

	if mmStartPlayback.defaultExpectation.paramPtrs == nil {
		mmStartPlayback.defaultExpectation.paramPtrs = &PlaylistServiceMockStartPlaybackParamPtrs{}
	}
	mmStartPlayback.defaultExpectation.paramPtrs.ctx = &ctx
	mmStartPlayback.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmStartPlayback
}

// ExpectLoginParam2 sets up expected param login for PlaylistService.StartPlayback
func (mmStartPlayback *mPlaylistServiceMockStartPlayback) ExpectLoginParam2(login string) *mPlaylistServiceMockStartPlayback {
	if mmStartPlayback.mock.funcStartPlayback != nil {
		mmStartPlayback.mock.t.Fatalf("PlaylistServiceMock.StartPlayback mock is already set by Set")
	}

	if mmStartPlayback.defaultExpectation == nil {
		mmStartPlayback.defaultExpectation = &PlaylistServiceMockStartPlaybackExpectation{}
	}

	if mmStartPlayback.defaultExpectation.params != nil {
		mmStartPlayback.mock.t.Fatalf("PlaylistServiceMock.StartPlayback mock is already set by Expect")
	}

	if mmStartPlayback.defaultExpectation.paramPtrs == nil {
		mmStartPlayback.defaultExpectation.paramPtrs = &PlaylistServiceMockStartPlaybackParamPtrs{}
	}
	mmStartPlayback.defaultExpectation.paramPtrs.login = &login
	mmStartPlayback.defaultExpectation.expectationOrigins.originLogin = minimock.CallerInfo(1)

	return mmStartPlayback
}

// ExpectWgParam3 sets up expected param wg for PlaylistService.StartPlayback
func (mmStartPlayback *mPlaylistServiceMockStartPlayback) ExpectWgParam3(wg *sync.WaitGroup) *mPlaylistServiceMockStartPlayback {
	if mmStartPlayback.mock.funcStartPlayback != nil {
		mmStartPlayback.mock.t.Fatalf("PlaylistServiceMock.StartPlayback mock is already set by Set")
	}

	if mmStartPlayback.defaultExpectation == nil {
		mmStartPlayback.defaultExpectation = &PlaylistServiceMockStartPlaybackExpectation{}
	}

	if mmStartPlayback.defaultExpectation.params != nil {
		mmStartPlayback.mock.t.Fatalf("PlaylistServiceMock.StartPlayback mock is already set by Expect")
	}

	if mmStartPlayback.defaultExpectation.paramPtrs == nil {
		mmStartPlayback.defaultExpectation.paramPtrs = &PlaylistServiceMockStartPlaybackParamPtrs{}
	}
	mmStartPlayback.defaultExpectation.paramPtrs.wg = &wg
	mmStartPlayback.defaultExpectation.expectationOrigins.originWg = minimock.CallerInfo(1)

	return mmStartPlayback
}

// Inspect accepts an inspector function that has same arguments as the PlaylistService.StartPlayback
func (mmStartPlayback *mPlaylistServiceMockStartPlayback) Inspect(f func(ctx context.Context, login string, wg *sync.WaitGroup)) *mPlaylistServiceMockStartPlayback {
	if mmStartPlayback.mock.inspectFuncStartPlayback != nil {
		mmStartPlayback.mock.t.Fatalf("Inspect function is already set for PlaylistServiceMock.StartPlayback")
	}

	mmStartPlayback.mock.inspectFuncStartPlayback = f

	return mmStartPlayback
}

// Return sets up results that will be returned by PlaylistService.StartPlayback
func (mmStartPlayback *mPlaylistServiceMockStartPlayback) Return() *PlaylistServiceMock {
	if mmStartPlayback.mock.funcStartPlayback != nil {
		mmStartPlayback.mock.t.Fatalf("PlaylistServiceMock.StartPlayback mock is already set by Set")
	}

	if mmStartPlayback.defaultExpectation == nil {
		mmStartPlayback.defaultExpectation = &PlaylistServiceMockStartPlaybackExpectation{mock: mmStartPlayback.mock}
	}

	mmStartPlayback.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmStartPlayback.mock
}

// Set uses given function f to mock the PlaylistService.StartPlayback method
func (mmStartPlayback *mPlaylistServiceMockStartPlayback) Set(f func(ctx context.Context, login string, wg *sync.WaitGroup)) *PlaylistServiceMock {
	if mmStartPlayback.defaultExpectation != nil {
		mmStartPlayback.mock.t.Fatalf("Default expectation is already set for the PlaylistService.StartPlayback method")
	}

	if len(mmStartPlayback.expectations) > 0 {
		mmStartPlayback.mock.t.Fatalf("Some expectations are already set for the PlaylistService.StartPlayback method")
	}

	mmStartPlayback.mock.funcStartPlayback = f
	mmStartPlayback.mock.funcStartPlaybackOrigin = minimock.CallerInfo(1)
	return mmStartPlayback.mock
}

// Times sets number of times PlaylistService.StartPlayback should be invoked
func (mmStartPlayback *mPlaylistServiceMockStartPlayback) Times(n uint64) *mPlaylistServiceMockStartPlayback {
	if n == 0 {
		mmStartPlayback.mock.t.Fatalf("Times of PlaylistServiceMock.StartPlayback mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStartPlayback.expectedInvocations, n)
	mmStartPlayback.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmStartPlayback
}

func (mmStartPlayback *mPlaylistServiceMockStartPlayback) invocationsDone() bool {
	if len(mmStartPlayback.expectations) == 0 && mmStartPlayback.defaultExpectation == nil && mmStartPlayback.mock.funcStartPlayback == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStartPlayback.mock.afterStartPlaybackCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStartPlayback.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// StartPlayback implements mm_playlist.PlaylistService
func (mmStartPlayback *PlaylistServiceMock) StartPlayback(ctx context.Context, login string, wg *sync.WaitGroup) {
	mm_atomic.AddUint64(&mmStartPlayback.beforeStartPlaybackCounter, 1)
	defer mm_atomic.AddUint64(&mmStartPlayback.afterStartPlaybackCounter, 1)

	mmStartPlayback.t.Helper()

	if mmStartPlayback.inspectFuncStartPlayback != nil {
		mmStartPlayback.inspectFuncStartPlayback(ctx, login, wg)
	}

	mm_params := PlaylistServiceMockStartPlaybackParams{ctx, login, wg}

	// Record call args
	mmStartPlayback.StartPlaybackMock.mutex.Lock()
	mmStartPlayback.StartPlaybackMock.callArgs = append(mmStartPlayback.StartPlaybackMock.callArgs, &mm_params)
	mmStartPlayback.StartPlaybackMock.mutex.Unlock()

	for _, e := range mmStartPlayback.StartPlaybackMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmStartPlayback.StartPlaybackMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStartPlayback.StartPlaybackMock.defaultExpectation.Counter, 1)
		mm_want := mmStartPlayback.StartPlaybackMock.defaultExpectation.params
		mm_want_ptrs := mmStartPlayback.StartPlaybackMock.defaultExpectation.paramPtrs

		mm_got := PlaylistServiceMockStartPlaybackParams{ctx, login, wg}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmStartPlayback.t.Errorf("PlaylistServiceMock.StartPlayback got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStartPlayback.StartPlaybackMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.login != nil && !minimock.Equal(*mm_want_ptrs.login, mm_got.login) {
				mmStartPlayback.t.Errorf("PlaylistServiceMock.StartPlayback got unexpected parameter login, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStartPlayback.StartPlaybackMock.defaultExpectation.expectationOrigins.originLogin, *mm_want_ptrs.login, mm_got.login, minimock.Diff(*mm_want_ptrs.login, mm_got.login))
			}

			if mm_want_ptrs.wg != nil && !minimock.Equal(*mm_want_ptrs.wg, mm_got.wg) {
				mmStartPlayback.t.Errorf("PlaylistServiceMock.StartPlayback got unexpected parameter wg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmStartPlayback.StartPlaybackMock.defaultExpectation.expectationOrigins.originWg, *mm_want_ptrs.wg, mm_got.wg, minimock.Diff(*mm_want_ptrs.wg, mm_got.wg))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStartPlayback.t.Errorf("PlaylistServiceMock.StartPlayback got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmStartPlayback.StartPlaybackMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmStartPlayback.funcStartPlayback != nil {
		mmStartPlayback.funcStartPlayback(ctx, login, wg)
		return
	}
	mmStartPlayback.t.Fatalf("Unexpected call to PlaylistServiceMock.StartPlayback. %v %v %v", ctx, login, wg)

}

// StartPlaybackAfterCounter returns a count of finished PlaylistServiceMock.StartPlayback invocations
func (mmStartPlayback *PlaylistServiceMock) StartPlaybackAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStartPlayback.afterStartPlaybackCounter)
}

// StartPlaybackBeforeCounter returns a count of PlaylistServiceMock.StartPlayback invocations
func (mmStartPlayback *PlaylistServiceMock) StartPlaybackBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStartPlayback.beforeStartPlaybackCounter)
}

// Calls returns a list of arguments used in each call to PlaylistServiceMock.StartPlayback.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStartPlayback *mPlaylistServiceMockStartPlayback) Calls() []*PlaylistServiceMockStartPlaybackParams {
	mmStartPlayback.mutex.RLock()

	argCopy := make([]*PlaylistServiceMockStartPlaybackParams, len(mmStartPlayback.callArgs))
	copy(argCopy, mmStartPlayback.callArgs)

	mmStartPlayback.mutex.RUnlock()

	return argCopy
}

// MinimockStartPlaybackDone returns true if the count of the StartPlayback invocations corresponds
// the number of defined expectations
func (m *PlaylistServiceMock) MinimockStartPlaybackDone() bool {
	if m.StartPlaybackMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StartPlaybackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StartPlaybackMock.invocationsDone()
}

// MinimockStartPlaybackInspect logs each unmet expectation
func (m *PlaylistServiceMock) MinimockStartPlaybackInspect() {
	for _, e := range m.StartPlaybackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PlaylistServiceMock.StartPlayback at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterStartPlaybackCounter := mm_atomic.LoadUint64(&m.afterStartPlaybackCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StartPlaybackMock.defaultExpectation != nil && afterStartPlaybackCounter < 1 {
		if m.StartPlaybackMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PlaylistServiceMock.StartPlayback at\n%s", m.StartPlaybackMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PlaylistServiceMock.StartPlayback at\n%s with params: %#v", m.StartPlaybackMock.defaultExpectation.expectationOrigins.origin, *m.StartPlaybackMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStartPlayback != nil && afterStartPlaybackCounter < 1 {
		m.t.Errorf("Expected call to PlaylistServiceMock.StartPlayback at\n%s", m.funcStartPlaybackOrigin)
	}

	if !m.StartPlaybackMock.invocationsDone() && afterStartPlaybackCounter > 0 {
		m.t.Errorf("Expected %d calls to PlaylistServiceMock.StartPlayback at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.StartPlaybackMock.expectedInvocations), m.StartPlaybackMock.expectedInvocationsOrigin, afterStartPlaybackCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PlaylistServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddSongInspect()

			m.MinimockCloseActionCHInspect()

			m.MinimockDeleteSongInspect()

			m.MinimockNextSongInspect()

			m.MinimockPauseSongInspect()

			m.MinimockPlaySongInspect()

			m.MinimockPrevSongInspect()

			m.MinimockStartPlaybackInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PlaylistServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PlaylistServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddSongDone() &&
		m.MinimockCloseActionCHDone() &&
		m.MinimockDeleteSongDone() &&
		m.MinimockNextSongDone() &&
		m.MinimockPauseSongDone() &&
		m.MinimockPlaySongDone() &&
		m.MinimockPrevSongDone() &&
		m.MinimockStartPlaybackDone()
}
